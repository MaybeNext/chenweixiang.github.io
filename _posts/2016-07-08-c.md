---
layout: post
title: "C"
tag: Programming Languages
toc: true
---

This article introduces the **C** programming language.

<!--more-->

# Overview

The **C** programming language was developed in **1972** by ***Dennis Ritchie*** and ***Brian Kernighan*** at the AT&T Corporation for programming computer operating systems. Its capacity to structure data and programs through the composition of smaller units is comparable to that of ALGOL (Algorithmic Language). It uses a compact notation and provides the programmer with the ability to operate with the addresses of data as well as with their values. This ability is important in systems programming, and C shares with assembly language the power to exploit all the features of a computer’s internal architecture.

# C Standards

Refer to [C Standard Committee (ISO/IEC JTC1/SC22/WG14)](http://www.open-std.org/JTC1/SC22/WG14/www/standards):

![C Language Evolution](/assets/C_Language_Evolution.png)

* **K&R C**

    First edition of ***The C Programming Language*** published by ***Brian Kernighan*** and ***Dennis Ritchie*** in 1978. This book, known to C programmers as **K&R**, served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as **K&R C**.

* **ANSI X3.159-1989 (ANSI C, C89)**

    In 1983, the **American National Standards Institute (ANSI)** formed a committee, **X3J11**, to establish a standard specification of C. **X3J11** based the C standard on the Unix implementation; however, the non-portable portion of the Unix C library was handed off to the **IEEE working group 1003** to become the basis for the 1988 POSIX standard. In 1989, the C standard was ratified as **ANSI X3.159-1989** ***Programming Language C***. This version of the language is often referred to as **ANSI C**, **Standard C**, or sometimes **C89**.

* **ISO/IEC 9899:1990 (C90)**

    In 1990, the **ANSI C** standard (with formatting changes) was adopted by the International Organization for Standardization (ISO) [C Standard Committee (ISO/IEC JTC1/SC22/WG14 - C)](http://www.open-std.org/JTC1/SC22/WG14/www/standards) as **ISO/IEC 9899:1990**, which is sometimes called **C90**. Therefore, the terms **C89** and **C90** refer to the same programming language.

    It has since been amended three times by Technical Corrigenda (COR) or Amendment (AMD):

    * **ISO/IEC 9899:1990/AM1:1995** (known as **C90 AMD1** or **C95**)
    * **ISO/IEC 9899:1990/COR1:1995**
    * **ISO/IEC 9899:1990/COR2:1996**
     <p/>

* **ISO/IEC9899:1999 (C99)**

    The C standard was further revised in the late 1990s, leading to the publication of **ISO/IEC 9899:1999** in 1999, which is commonly referred to as **C99**.

    It has since been amended three times by Technical Corrigenda (COR):

    * **ISO/IEC 9899:1999/COR1:2001**
    * **ISO/IEC 9899:1999/COR2:2004**
    * **ISO/IEC 9899:1999/COR3:2007**
     <p/>

* **ISO/IEC 9899:2011 (C11)**

    In 2007, work began on another revision of the C standard, informally called **C1X** until its official publication on 2011-12-08. The C standards committee adopted guidelines to limit the adoption of new features that had not been tested by existing implementations. The **C11** standard adds numerous new features to C and the library, including type generic macros, anonymous structures, improved Unicode support, atomic operations, multi-threading, and bounds-checked functions. It also makes some portions of the existing **C99** library optional, and improves compatibility with C++.

    It has since been amended by Technical Corrigenda:

    * **ISO/IEC 9899:2011/COR1:2012**
     <p/>

* **Embedded C**

    Historically, embedded C programming requires nonstandard extensions to the C language in order to support exotic features. In 2008, the C Standards Committee published a technical report [TR 18037: Embedded C](/docs/ISO-IEC_TR_18037.pdf) extending the C language to address these issues by providing a common standard for all implementations to adhere to. It includes a number of features not available in normal C, such as fixed-point arithmetic, named address spaces, and basic I/O hardware addressing.

# C Language

## Translation Phases

The C source file is processed by the compiler *as if* the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same. Refer to [Phases of translation](http://en.cppreference.com/w/c/language/translation_phases).

### Phase 1

* The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the *source character set*. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The *source character set* is a multibyte character set which includes the *basic source character set* as a single-byte subset, consisting of the following 96 characters:

    * 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)
    * 10 digit characters from ```0``` to ```9```
    * 52 letters from ```a``` to ```z``` and from ```A``` to ```Z```
    * 29 punctuation characters: ```_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’```
    <p/>

* **Trigraph sequences** are replaced by corresponding single-character representations.

| Primary | Trigraph  |
| :-----: | :-------: |
| ```{``` | ```??<``` |
| ```}``` | ```??>``` |
| ```[``` | ```??(``` |
| ```]``` | ```??)``` |
| ```#``` | ```??=``` |
| ```\``` | ```??/``` |
| ```^``` | ```??'``` |
| ```|``` | ```??!``` |
| ```~``` | ```??-``` |

<p/>

### Phase 2

* Whenever backslash ```\``` appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one.

* If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.

### Phase 3

* The source file is decomposed into comments, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and *preprocessing tokens*, which are the following

    * header names: ```<stdio.h>``` or ```"myfile.h"```
    * identifiers
    * numbers
    * character constants and string literals
    * operators and punctuators (including alternative tokens), such as ```+```, ```<<=```, ```<%```, ```##```, or ```and```
    * individual non-whitespace characters that do not fit in any other category
    <p/>

* Each comment is replaced by one space character.

* Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.

### Phase 4

* Preprocessor is executed.
* Each file introduced with the ```#include``` directive goes through **phases 1** through **4**, recursively.
* At the end of this phase, all preprocessor directives are removed from the source.

### Phase 5

* All characters and escape sequences in character constants and string literals are converted from *source character set* to *execution character set* (which may be a multibyte character set such as UTF-8, as long as all 96 characters from the *basic source character set* listed in **phase 1** have single-byte representations). If the character specified by an escape sequence isn't a member of the *execution character set*, the result is implementation-defined, but is guaranteed to not be a null (wide) character.

    Note: the conversion performed at this stage can be controlled by command line options in some implementations: *gcc* and *clang* use ```-finput-charset``` to specify the encoding of the source character set, ```-fexec-charset``` and ```-fwide-exec-charset``` to specify the encodings of the *execution character set* in the string and character literals that don't have an encoding prefix (since **C11**).

### Phase 6

* Adjacent string literals are concatenated.

### Phase 7

* Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a **translation unit**.

### Phase 8

* Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).

## Keywords

This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.

| Keywords | Standard  | Note |
| :------- | :-------- | :--- |
| auto     | since C89 |      |
| break    | since C89 |      |
| case     | since C89 |      |
| char     | since C89 |      |
| const    | since C89 |      |
| continue | since C89 |      |
| default  | since C89 |      |
| do       | since C89 |      |
| double   | since C89 |      |
| else     | since C89 |      |
| enum     | since C89 |      |
| extern   | since C89 |      |
| float    | since C89 |      |
| for      | since C89 |      |
| goto     | since C89 |      |
| if       | since C89 |      |
| inline   | since **C99** |      |
| int      | since C89 |      |
| long     | since C89 |      |
| register | since C89 |      |
| restrict | since **C99** |      |
| return   | since C89 |      |
| short    | since C89 |      |
| signed   | since C89 |      |
| sizeof   | since C89 |      |
| static   | since C89 |      |
| struct   | since C89 |      |
| switch   | since C89 |      |
| typedef  | since C89 |      |
| union    | since C89 |      |
| unsigned | since C89 |      |
| void     | since C89 |      |
| volatile | since C89 |      |
| while    | since C89 |      |
| _Alignas | since **C11** |      |
| _Alignof | since **C11** |      |
| _Atomic  | since **C11** |      |
| _Bool    | since **C99** |      |
| _Complex | since **C99** | ```complex``` in ```complex.h``` |
| _Generic | since **C11** |      |
| _Imaginary | since **C99** | ```imaginary``` in ```complex.h``` |
| _Noreturn  | since **C11** |      |
| _Static_assert | since **C11** |      |
| _Thread_local  | since **C11** |      |

<p/>

Most of the recently reserved words begin with an underscore followed by a capital letter, because identifiers of that form were previously reserved by the C standard for use only by implementations. Since existing program source code should not have been using these identifiers, it would not be affected when C implementations started supporting these extensions to the programming language. Some standard headers do define more convenient synonyms for underscored identifiers. The language previously included a reserved word called *entry*, but this was seldom implemented, and has now been removed as a reserved word.

### sizeof

Whether you use parentheses ```()``` depends on whether you want the size of **a type** or the size of **a particular quantity**. Parentheses are required for types but are optional for particular quantities. That is, you would use ```sizeof(char)``` or ```sizeof(float)``` but can use ```sizeof name``` or ```sizeof 6.28```. However, it is all right to use parentheses in these cases, too, as in ```sizeof (6.28)```.

C says that ```sizeof``` returns a value of type ```size_t```. This is an unsigned integer type.

## Operators

| Operators                                               | Associativity     | Description |
| :------------------------------------------------------ | :---------------: | :---------- |
| `()` `[]` `->` `.`                                      | left to right     | Function call, array access, member access |
| `!` `~` `++` `--` `+` `-` `*` `(type)` `sizeof`         | **right to left** | Unary operators, increment operator, decrement operator, sign operators, type cast, sizeof |
| `*` `/` `%`                                             | left to right     | Arithmetic operators: multiplication, division, modulo |
| `+` `-`                                                 | left to right     | Arithmetic operators: addition, subtraction |
| `<<` `>>`                                               | left to right     | Bitwise operators: left shift, right shift |
| `<` `<=` `>` `>=`                                       | left to right     | Relational operators: less-than, less and equal than, larger than, larger and equal than |
| `==` `!=`                                               | left to right     | Relational operators: equal, not equal |
| `&`                                                     | left to right     | Bitwise operators: bitwise AND |
| `^`                                                     | left to right     | Bitwise operators: bitwise exclusive OR (XOR) |
| `|`                                                     | left to right     | Bitwise operators: bitwise inclusive OR |
| `&&`                                                    | left to right     | Logical operators: AND |
| `||`                                                    | left to right     | Logical operators: OR |
| `?:`                                                    | **right to left** | Conditional expression (ternary) |
| `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `|=` | **right to left** | Assignment operators |
| `,`                                                     | left to right     | Comma operator |

<p/>

Run the following command to get the operator priority under Linux environment:

```
chenwx@chenwx ~ $ man operator

NAME
       operator - C operator precedence and order of evaluation

DESCRIPTION
       This manual page lists C operators and their precedence in evaluation.

       Operator                             Associativity
       () [] -> .                           left to right
       ! ~ ++ -- + - (type) * & sizeof      right to left
       * / %                                left to right
       + -                                  left to right
       << >>                                left to right
       < <= > >=                            left to right
       == !=                                left to right
       &                                    left to right
       ^                                    left to right
       |                                    left to right
       &&                                   left to right
       ||                                   left to right
       ?:                                   right to left
       = += -= *= /= %= <<= >>= &= ^= |=    right to left
       ,                                    left to right

COLOPHON
       This page is part of release 3.54 of the Linux man-pages project.  A description of the project, and information about reporting bugs, can befound at http://www.kernel.org/doc/man-pages/.
```

## Comments

**C-style comments** or **multi-line comments**

```
/* comment */
```

**C++-style comments** or **single-line comments** (since **C99**)

```
// comment until end of the line
```

## Preprocessor

The preprocessor is executed at [translation phase 4](#phases-of-translation), before the compilation. The result of preprocessing is single file which is then passed to the actual compiler. Refer to [Preprocessor](http://en.cppreference.com/w/c/preprocessor).

The preprocessor has the source file translation capabilities:

* Conditionally compile of parts of source file: ```#if```, ```#ifdef```, ```#ifndef```, ```#else```, ```#elif``` and ```#endif```
* Replace text macros while possibly concatenating or quoting identifiers: ```#define``` and ```#undef```, and operators ```#``` and ```##```
* Include other files: ```#include```
* Cause an error: ```#error```

The following aspects of the preprocessor can be controlled:

* Implementation defined behavior: ```#pragma``` and operator ```_Pragma``` (since C99)
* File name and line information available to the preprocessor: ```#line```

NOTE: Those preprocessor directives are defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive ```#warning``` which emits a user-defined message during compilation.

The output of preprocessing of source file *example.c* to file *example.l*:

```
gcc -E -o example.l example.c
```

### File Inclusion

```
#include "filename"
#include <filename>
```

If the *filename* is quoted, searching for the file typically begins where the source program was found; if it is not found there, or if the *filename* is enclosed in ```<``` and ```>```, searching follows an implementation-defined rule to find the file. An included file may itself contain ```#include``` lines.

There are often several ```#include``` lines at the beginning of a source file, to include common ```#define``` statements and *extern* declarations, or to access the function prototype declarations for library functions from headers like ```<stdio.h>```.

Naturally, when an included file is changed, all files that depend on it must be recompiled.

### Macros

#### Macros without Arguments

```
#define NAME replacement text
```

* The *NAME* in a ```#define``` has the same form as a variable name; the *replacement text* is arbitrary.
* Capitalizing constants *NAME* is just another technique to make programs more readable.
* Normally the *replacement text* is the rest of the line, but a long definition may be continued onto several lines by placing a ```\``` at the end of each line to be continued.
* There is no semicolon at the end of a ```#define``` line because this is a substitution mechanism, not a C statement.

* The scope of a name defined with ```#define``` is from its point of definition to the end of the source file being compiled.
* A definition may use previous definitions.
* Substitutions are made only for tokens, and do not take place within quoted strings.

**Substitution**

C90 added a second way to create symbolic constants -- using the const keyword to convert a declaration for a variable into a declaration for a constant. This newer approach is more flexible than using ```#define```:

```
const int MONTHS = 12;
```

Actually, C has yet a third way to create symbolic constants, and that is the ```enum``` facility.

#### Macros with Arguments

```
#define max(A, B) ((A) > (B) ? (A) : (B))
```

* It is also possible to define macros with arguments, so the replacement text can be different for different calls of the macro.
* Some care also has to be taken with parentheses to make sure the order of evaluation is preserved, such as, ```#define square(x) x * x```

```
#undef getchar
int getchar(void)
{
    ...
}
```

* Names may be undefined with ```#undef```, usually to ensure that a routine is really a function, not a macro.

### Conditional Inclusion

```
#ifndef HDR
#define HDR
/* contents of hdr.h go here */
#endif
```

* It is possible to control preprocessing itself with conditional statements that are evaluated during preprocessing.
* This provides a way to include code selectively, depending on the value of conditions evaluated during compilation.

## Escape Sequences

Escape sequences are used to represent certain special characters within string literals and character constants. The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:

| Escape sequence  |      Description      | Representation | Means |
| :--------------- | :-------------------- | :------------- | :---- |
| ```\'```         | single quote          | byte 0x27 (in ASCII encoding) | character constant ```'``` |
| ```\"```         | double quote          | byte 0x22 (in ASCII encoding) | character constant ```"``` |
| ```\?```         | question mark         | byte 0x3f (in ASCII encoding) | character constant ```?``` |
| ```\\```         | backslash             | byte 0x5c (in ASCII encoding) | character constant ```\``` |
| ```\a```         | audible bell          | byte 0x07 (in ASCII encoding) | produces an audible or visible alert, which shall not change the active position. |
| ```\b```         | backspace             | byte 0x08 (in ASCII encoding) | moves the active position back one space on the current line. |
| ```\f```         | form feed / new page  | byte 0x0c (in ASCII encoding) | moves the active position to the start of the next page. |
| ```\n```         | line feed / new line  | byte 0x0a (in ASCII encoding) | moves the active position to the beginning of the next line. |
| ```\r```         | carriage return       | byte 0x0d (in ASCII encoding) | moves the active position to the beginning of the current line. |
| ```\t```         | horizontal tab        | byte 0x09 (in ASCII encoding) | moves the active position to the next horizontal tab stop. |
| ```\v```         | vertical tab          | byte 0x0b (in ASCII encoding) | moves the active position to the next vertical tab position. |
| ```\nnn```       | arbitrary octal value | byte nnn | |
| ```\xnn```<br>```\Xnn``` | arbitrary hexadecimal value | byte nn | |
| ```\unnnn```     | Unicode character that is not in the basic character set. May result in several characters. | code point U+nnnn | |
| ```\Unnnnnnnn``` | Unicode character that is not in the basic character set. May result in several characters. | code point U+nnnnnnnn | |

<p/>

* The escape sequence represents only a single character.
* The escape sequences provides a general and extensible mechanism for representing hard-to-type or invisible characters.

## Fundamental Data Types

The C language provides the four basic arithmetic type specifiers **char**, **int**, **float** and **double**, and the modifiers **signed**, **unsigned**, **short** and **long**.

The actual size of **integer** types varies by implementation. The standard only requires size relations between the data types and minimum sizes for each data type:

```long long``` => ```long``` => ```int``` => ```short``` => ```char```

That's, the relation requirements are that the ```long long``` (at least 64 bits) is not smaller than ```long``` (at least 32 bits), which is not smaller than ```int``` (at least 16 bits), which is not smaller than ```short``` (at least 16 bits). As size of ```char``` (at least 8 bits) is always the minimum supported data type, no other data types (except bit-fields) can be smaller.

The actual size and behavior of **floating-point** types also vary by implementation. The only guarantee is that ```long double``` is not smaller than ```double```, which is not smaller than ```float```. Usually, the 32-bit and 64-bit IEEE 754 binary floating-point formats are used, if supported by hardware.

The following sections list the permissible combinations to specify a large set of storage size-specific declarations, refer to [C Data Types](https://en.wikipedia.org/wiki/C_data_types).

### char

| Standard         | since **C89** |
| Format Specifier | Character output: ```%c```<br>Numerical output: refer to **unsigned char** or **signed char** |
| Size             | **at least 8 bits** |
| Explanation      | Smallest addressable unit of the machine that can contain basic character set. It is an *integer* type. **Actual type can be either signed or unsigned depending on the implementation**. Your compiler manual should tell you which type your *char* is, or you can check the ```limits.h``` header file. Also refer to [Escape Sequences](#escape-sequences) |
| Constants        | A character constant is an integer, written as one character within single quotes, such as ```char c = 'A'``` or ```char c = 65```, ```char c = \0x41```, ```char c = \0101```. |

<p/>

### signed char

| Standard         | since **C89** |
| Format Specifier | Character output: ```%c```<br>Numerical output:<br>Decimal notation: ```%hhi```, ```%hhd``` |
| Size             | **at least 8 bits** |
| Explanation      | Of the same size as **char**, but guaranteed to be signed. Also refer to [Escape Sequences](#escape-sequences) |
| Constants        | A character constant is an integer, written as one character within single quotes, such as ```char c = 'A'``` or ```char c = 65```. |

<p/>

### unsigned char

| Standard         | since **C89** |
| Format Specifier | Character output: ```%c```<br>Numerical output:<br>Decimal notation: ```%hhu```<br>Octal notation: ```%hho```, ```%#hho```<br>Hexadecimal notation: ```%hhx```, ```%#hhx```, ```%hhX```, ```%#hhx``` |
| Size             | **at least 8 bits** |
| Explanation      | Of the same size as **char**, but guaranteed to be unsigned. It is represented in binary notation without padding bits; thus, its range is exactly [0, 2^CHAR_BIT - 1]. Also refer to [Escape Sequences](#escape-sequences) |
| Constants        | A character constant is an integer, written as one character within single quotes, such as ```char c = 'A'``` or ```char c = 65```. |

<p/>

### short / short int / signed short / signed short int

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%hi```, ```%hd```<br>Octal notation: ```%ho```, ```%#ho```<br>Hexadecimal notation: ```%hx```, ```%#hx```, ```%#hX``` |
| Size             | **at least 16 bits** |
| Explanation      | Short signed integer type. |
| Constants        | |

<p/>

### unsigned short / unsigned short int

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%hu```<br>Octal notation: ```%ho```, ```%#ho```<br>Hexadecimal notation: ```%hx```, ```%#hx```, ```%#hX``` |
| Size             | **at least 16 bits** |
| Explanation      | Similar to **short**, but unsigned. |
| Constants        | |

<p/>

### int / signed / signed int

The ```int``` type is a signed integer. That means it must be an integer and it can be positive, negative, or zero. The range in possible values depends on the computer system.

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%i```, ```%d```<br>Octal notation: ```%o```, ```%#o```<br>Hexadecimal notation: ```%x```, ```%#x```, ```%#X``` |
| Size             | **at least 16 bits**. Typically, it uses one machine *word* for storage. |
| Explanation      | Basic signed integer type. |
| Constants        | A int constant is written without suffix, as ```1234```, ```02322```, ```0x4D2``` |

<p/>

### unsigned / unsigned int

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%u``` |
| Size             | **at least 16 bits** |
| Explanation      | Similar to **int**, but unsigned. |
| Constants        | An unsigned int constant is written with a terminal ```u``` or ```U``` (perfer ```U```), as ```1234U```, ```02322U```, ```0x4D2U``` |

<p/>

When do you use the various *int* types? First, consider **unsigned** types. It is natural to use them for counting because you don't need negative numbers, and the **unsigned** types enable you to reach higher positive numbers than the signed types.

### long / long int / signed long / signed long int

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%li``` or ```%ld``` |
| Size             | **at least 32 bits** |
| Explanation      | Long signed integer type. |
| Constants        | A long constant is written with a terminal ```l``` or ```L``` (perfer ```L```), as in ```1234L```, ```02322L```, ```0x4D2L``` |

<p/>

### unsigned long / unsigned long int

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%lu```<br>Octal notation: ```%lo```, ```%#lo```<br>Hexadecimal notation: ```%lx```, ```%#lx```, ```%#lX``` |
| Size             | **at least 32 bits** |
| Explanation      | Similar to **long**, but unsigned. |
| Constants        | A unsigned long constant is written with a terminal ```ul``` or ```UL``` (perfer ```UL```), as in ```1234UL```, ```02322UL```, ```0x4D2UL``` |

<p/>

### long long / long long int / signed long long / signed long long int

| Standard         | since **C99** |
| Format Specifier | Decimal notation: ```%lli``` or ```%lld``` |
| Size             | **at least 64 bits** |
| Explanation      | Long long signed integer type. |
| Constants        | A long long constant is written with a terminal ```ll``` or ```LL``` (perfer ```LL```), as in ```1234LL```, ```02322LL```, ```0x4D2LL``` |

<p/>

### unsigned long long / unsigned long long int

| Standard         | since **C99** |
| Format Specifier | Decimal notation: ```%llu```<br>Octal notation: ```%llo```, ```%#llo```<br>Hexadecimal notation: ```%llx```, ```%#llx```, ```%#llX``` |
| Size             | **at least 64 bits** |
| Explanation      | Similar to **long long**, but unsigned. |
| Constants        | A unsigned long long constant is written with a terminal ```ull```, ```llu``` or ```ULL```, ```LLU``` (perfer ```ULL```), as in ```1234ULL```, ```02322ULL```, ```0x4D2ULL``` |

<p/>

### float

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%f```, promoted automatically to **double** for printf() |
| Size             | |
| Explanation      | Real floating-point type, usually referred to as a single-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the **IEEE 754 single-precision binary floating-point format**. This format is required by the optional **Annex F: IEC 60559 floating-point arithmetic**. Accurate: 6 digits |
| Constants        | An float constant is written with a terminal ```f``` or ```F``` (perfer ```F```), as ```123.4F```, ```1.234e5F```, ```1.234E-5F``` |

<p/>

### double

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%f```, ```%F```<br>Exponential notation: ```%e```, ```%E```<br>Decimal or exponential notation depending on the value: ```%g```, ```%G```<br>Hexadecimal notation (since C99): ```%a```, ```%A```<br>For scanf(): ```%lf``` or ```%lF``` |
| Size             | |
| Explanation      | Real floating-point type, usually referred to as a double-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the **IEEE 754 double-precision binary floating-point format**. This format is required by the optional **Annex F: IEC 60559 floating-point arithmetic**. Accurate: 10 digits |
| Constants        | An double constant is written without suffix, as ```123.4```, ```1.234e+5```, ```1.234E-5``` |

<p/>

### long double

| Standard         | since **C89** |
| Format Specifier | Decimal notation: ```%Lf``` or ```%LF```<br>Exponential notation: ```%Le```, ```%LE```<br>Decimal or exponential notation depending on the value: ```%Lg```, ```%LG```<br>Hexadecimal notation (since C99): ```%La```, ```%LA``` |
| Size             | |
| Explanation      | Real floating-point type, usually mapped to an extended precision floating-point number format. Actual properties unspecified. Unlike types **float** and **double**, it can be either 80-bit floating point format, the non-IEEE **double-double** or **IEEE 754 quadruple-precision floating-point format** if a higher precision format is provided, otherwise it is the same as double. Accurate: 10 digits |
| Constants        | An float constant is written with a terminal ```l``` or ```L``` (prefer ```L```), as ```123.4L``` |

<p/>

### _Bool

* Boolean values represent ```true``` and ```false```; C uses 1 for ```true``` and 0 for ```false```.
* It is an **unsigned int** and need only be large enough to accommodate the range 0 through 1.

### Properties of Fundamental Data Type

Information about the actual properties, such as size, of the basic arithmetic types, is provided via macro constants in two headers:

* ```<limits.h>``` header (```climits``` header in C++) defines macros for integer types
* ```<float.h>``` header (```cfloat``` header in C++) defines macros for floating-point types

The actual values depend on the implementation.

#### Properties of Integer Types

| Macros     | Description |
| :--------- | :---------- |
| CHAR_BIT   | size of the **char** type in bits, at least 8 bits |
| CHAR_MIN   | minimum possible value of **char** type |
| CHAR_MAX   | maximum possible value of **char** type |
| MB_LEN_MAX | maximum number of bytes in a multibyte character |
| SCHAR_MIN  | minimum possible value of **signed char** type |
| SCHAR_MAX  | maximum possible value of **signed char** type |
| UCHAR_MAX  | maximum possible value of **unsigned char** type |
| SHRT_MIN   | minimum possible value of **signed short** type |
| SHRT_MAX   | maximum possible value of **signed short** type |
| USHRT_MAX  | maximum possible value of **unsigned short** type |
| INT_MIN    | minimum possible value of **signed int** type |
| INT_MAX    | maximum possible value of **signed int** type |
| UINT_MAX   | maximum possible value of **unsigned int** type |
| LONG_MIN   | minimum possible value of **signed long** type |
| LONG_MAX   | maximum possible value of **signed long** type |
| ULONG_MAX  | maximum possible value of **unsigned long** type |
| LLONG_MIN  | (since C99) minimum possible value of **signed long long** type |
| LLONG_MAX  | (since C99) maximum possible value of **signed long long** type |
| ULLONG_MAX | (since C99) maximum possible value of **unsigned long long** type |

<p/>

#### Properties of Floating-point Types

| Macros          | Description |
| :-------------- | :---------- |
| FLT_MIN         | minimum normalized positive value of **float** type |
| DBL_MIN         | minimum normalized positive value of **double** type |
| LDBL_MIN        | minimum normalized positive value of **long double** type |
| FLT_TRUE_MIN    | minimum positive value of **float** type |
| DBL_TRUE_MIN    | minimum positive value of **double** type |
| LDBL_TRUE_MIN   | (since C11) minimum positive value of **long double** type |
| FLT_MAX         | maximum finite value of **float** type |
| DBL_MAX         | maximum finite value of **double** type |
| LDBL_MAX        | maximum finite value of **long double** type |
| FLT_ROUNDS      | rounding mode for floating-point operations |
| FLT_EVAL_METHOD | (since C99) evaluation method of expressions involving different floating-point types |
| FLT_RADIX       | radix of the exponent in the floating-point types |
| FLT_DIG         | number of decimal digits that can be represented without losing precision by **float** type |
| DBL_DIG         | number of decimal digits that can be represented without losing precision by **double** type |
| LDBL_DIG        | number of decimal digits that can be represented without losing precision by **long double** type |
| FLT_EPSILON     | difference between 1.0 and the next representable value of **float** type |
| DBL_EPSILON     | difference between 1.0 and the next representable value of **double** type |
| LDBL_EPSILON    | difference between 1.0 and the next representable value of **long double** type |
| FLT_MANT_DIG    | number of **FLT_RADIX**-base digits in the floating-point significand for **float** type |
| DBL_MANT_DIG    | number of **FLT_RADIX**-base digits in the floating-point significand for **double** type |
| LDBL_MANT_DIG   | number of **FLT_RADIX**-base digits in the floating-point significand for **long double** type |
| FLT_MIN_EXP     | minimum negative integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **float** type |
| DBL_MIN_EXP     | minimum negative integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **double** type |
| LDBL_MIN_EXP    | minimum negative integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **long double** type |
| FLT_MIN_10_EXP  | minimum negative integer such that 10 raised to that power is a normalized **float** type |
| DBL_MIN_10_EXP  | minimum negative integer such that 10 raised to that power is a normalized **double** type |
| LDBL_MIN_10_EXP | minimum negative integer such that 10 raised to that power is a normalized **long double** type |
| FLT_MAX_EXP     | maximum positive integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **float** type |
| DBL_MAX_EXP     | maximum positive integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **double** type |
| LDBL_MAX_EXP    | maximum positive integer such that **FLT_RADIX** raised to a power one less than that number is a normalized **long double** type |
| FLT_MAX_10_EXP  | maximum positive integer such that 10 raised to that power is a normalized **float** type |
| DBL_MAX_10_EXP  | maximum positive integer such that 10 raised to that power is a normalized **double** type |
| LDBL_MAX_10_EXP | maximum positive integer such that 10 raised to that power is a normalized **long double** type |
| DECIMAL_DIG     | (since C99) minimum number of decimal digits such that any number of the widest supported floating-point type can be represented in decimal with a precision of **DECIMAL_DIG** digits and read back in the original floating-point type without changing its value. **DECIMAL_DIG** is at least 10. |

<p/>

#### Fixed-width Integer Types

The **C99** standard includes definitions of several new integer types to enhance the portability of programs. The already available basic integer types were deemed insufficient, because their actual sizes are implementation defined and may vary across different systems. The new types are especially useful in embedded environments where hardware usually supports only several types and that support varies between different environments. All new types are defined in ```<inttypes.h>``` header (```cinttypes``` header in C++) and also are available at ```<stdint.h>``` header (```cstdint``` header in C++). The types can be grouped into the following categories:

* **Exact-width integer types** which are guaranteed to have the same number **N** of bits across all implementations. Included only if it is available in the implementation.
* **Least-width integer types** which are guaranteed to be the smallest type available in the implementation, that has at least specified number **N** of bits. Guaranteed to be specified for at least **N** = 8, 16, 32, 64.
* **Fastest integer types** which are guaranteed to be the fastest integer type available in the implementation, that has at least specified number **N** of bits. Guaranteed to be specified for at least **N** = 8, 16, 32, 64.
* **Pointer integer types** which are guaranteed to be able to hold a pointer. Included only if it is available in the implementation.
* **Maximum-width integer types** which are guaranteed to be the largest integer type in the implementation.

The following table summarizes the types and the interface to acquire the implementation details (**N** refers to the number of bits):

![C_Fixed-width_Integer_Types](/assets/C_Fixed-width_Integer_Types.png)

### Type Conversions

The basic rules of type conversion are:

1. When appearing in an expression, ```char``` and ```short```, both ```signed``` and ```unsigned```, are automatically converted to ```int``` or, if necessary, to ```unsigned int``` (If ```short``` is the same size as ```int```, ```unsigned short``` is larger than ```int```; in that case, ```unsigned short``` is converted to ```unsigned int```). Under **K&R C**, but not under current C, ```float``` is automatically converted to ```double```. Because they are conversions to larger types, they are called *promotions*.
2. In any operation involving two types, both values are converted to the higher ranking of the two types.
3. The ranking of types, from highest to lowest, is ```long double```, ```double```, ```float```, ```unsigned long long```, ```long long```, ```unsigned long```, ```long```, ```unsigned int```, and ```int```. One possible exception is when ```long``` and ```int``` are the same size, in which case ```unsigned int``` outranks ```long```. The ```short``` and ```char``` types don't appear in this list because they would have been already promoted to ```int``` or perhaps ```unsigned int```.
4. In an assignment statement, the final result of the calculations is converted to the type of the variable being assigned a value. This process can result in *promotion*, as described in rule 1, or *demotion*, in which a value is converted to a lower-ranking type.
5. When passed as function arguments, ```char``` and ```short``` are converted to ```int```, and ```float``` is converted to ```double```. This automatic promotion can be overridden by function prototyping.

*Promotion* is usually a smooth, uneventful process, but *demotion* can lead to real trouble. The reason is simple: The lower-ranking type may not be big enough to hold the complete number. When floating types are demoted to integer types, they are truncated, or rounded toward zero. That means 23.12 and 23.99 both are truncated to 23 and that -23.5 is truncated to -23.

*(type)* : As the cast operator, converts the following value to the type specified by the enclosed keyword(s).

## Derived Data Types

### Arrays

* An array is a series of values of the same type, such as 10 chars or 15 ints, stored sequentially. The whole array bears a single name, and the individual items, or elements, are accessed by using an integer index.
* The numbers used to identify the array elements are called *subscripts*, *indices*, or *offsets*. The *subscripts* must be **integers** and the subscripting begins with **0**.
* **C99** allows you to use ```const``` values for specifying an array size, but **C90** didn't. ```#define``` works with both.

* An array may be initialized by following its declaration with a list of initializers enclosed in braces and separated by commas. ```int days[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };```
* When the size of the array is omitted, the compiler will compute the length by counting the initializers. ```int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };```
* If there are fewer initializers for an array than the specified size, the others will be zero for external, static and automatic variables. It is an error to have too many initializers.
* There is no way to specify repetition of an initializer, nor to initialize an element in the middle of an array without supplying all the preceding values as well.
* Character arrays are a special case of initialization; a string may be used instead of the braces and commas notation: ```char pattern = "ould";``` is a shorthand for the longer but equivalent ```char pattern[] = { 'o', 'u', 'l', 'd', '\0' };```

#### Character String

C language uses an array to hold a *character string*. A *character string* is a series of one or more characters. C uses *null character* ```\0``` to mark the end of a string.

```
char name[40] = "Zing went the strings of my heart!";
```

![A_string_in_an_array](/assets/A_string_in_an_array.png)

### Pointers

```
int i = 0;
int *p = &i;
```

* A pointer is a variable that contains the address of a variable.
* The ```&``` operator only applies to objects in memory: variables and array elements. It cannot be applied to expressions, constants, or register variables.
* Note that a pointer is constrained to point to a particular kind of object: every pointer points to a specific data type. Exception: a **pointer to void** ```void *``` is used to hold any type of pointer but cannot be dereferenced itself.
* Pointer arguments enable a function to access and change objects in the function that called it. ```char *strcpy(char *dest, const char *src);```
* There is one difference between an array name (for instance, ```int a[10];```) and a pointer (for instance, ```int *pa;```) that must be kept in mind. A pointer is a variable, so ```pa = a``` and ```pa++``` are legal. But an array name is not a variable; constructions like ```a = pa``` and ```a++``` are illegal.
* When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local variable, and so an array name parameter is a pointer, that is, a variable containing an address.
* If ```p``` is a pointer to some element of an array, then ```p++``` increments ```p``` to point to the next element, and ```p += i``` increments it to point ```i``` elements beyond where it currently does.
* The valid pointer operations are assignment of pointers of the same type, adding or subtracting a pointer and an integer, subtracting or comparing two pointers to members of the same array, and assigning or comparing to zero. All other pointer arithmetic is illegal.

#### Character Pointers

```
char amessage[] = "now is the time"; /* an array */
char *pmessage  = "now is the time"; /* a pointer */
```

In this example, the ```amessage``` is an array, just big enough to hold the sequence of characters and ```'\0'``` that initializes it. Individual characters within the array may be changed but ```amessage``` will always refer to the same storage. On the other hand, the ```pmessage``` is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.

#### Function Pointers

In C, a function itself is not a variable, but it is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on.

```
/* a function decleration */
int *func(int num);

/* a pointer to function, and assign a function to it */
int *(*pfunc)(int num);
pfunc = func;

/* an array of 10 pointers to function, and assign a function to the first element */
int *(*pfa[10])(int num);
pfa[0] = func;

/* typedef it for  */
typedef int *(*fp)(int num);
fp = func;
```

### Structures

* Structures are a way of storing multiple pieces of data in one variable.
* Structures may contain pointers to structs of its own type, which is common in linked data structures.
* A C implementation has freedom to design the memory layout of the struct, with few restrictions; one being that the memory address of the first member will be the same as the address of struct itself.
* Structs may be initialized or assigned to using compound literals.
* A user-written function can directly return a structure, though it will often not be very efficient at run-time.

```
struct Point {
    int x;
    int y;
};

struct Point ptA, ptB;

struct MorePoint {
    int x;
    int y;
    int y;
} ptC, ptD;
```

A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.

A ```struct``` declaration defines a type.

Structures can be nested.

The only legal operations on a structure are copying it or assigning to it as a unit, taking its address with &, and accessing its members. Copy and assignment include passing arguments to functions and returning values from functions as well.

Number of elements of array *keytab*:

```
struct key {
    char *word;
    int count;
} keytab[100];

#define NKEYS (sizeof keytab / sizeof(struct key))
#define NKEYS (sizeof keytab / sizeof(keytab[0]))
```

Note: A ```sizeof``` can not be used in a ```#if``` line, because the preprocessor does not parse type names. But the expression in the ```#define``` is not evaluated by the preprocessor, so the code here is legal.

#### Bit-fields

```
struct {
    unsigned int is_keyword : 1;
    unsigned int is_extern  : 1;
    unsigned int is_static  : 1;
} flags;
```

* Whether a field may overlap a word boundary is implementation-defined.
* Fields need not be names; unnamed fields (a colon and width only) are used for padding.
* The special width 0 may be used to force alignment at the next word boundary.
* Fields may be declared only as ```int```; for portability, specify ```signed``` or ```unsigned``` explicitly.
* They are not arrays and they do not have addresses, so the ```&``` operator cannot be applied on them.

#### Flexible Array Member

Since C99, a struct can also end with a **flexible array member**, which is an array without a given dimension, and it should be the last member of such a struct, as in the following example:

```
struct double_vector_st {
    size_t length;
    double array[]; // the flexible array member should be last
};
```

In previous standards of the C language, it was common to declare a zero-sized array member instead of a flexible array member. The GCC compiler explicitly accepts zero-sized arrays for such purposes.

C++ does not have flexible array members.

#### Offset of structure memebers

```
#include <stdio.h>
#include <stddef.h>

struct S {
    char   c;
    double d;
};

int main(void)
{
    printf("the first element is at offset %zu\n", offsetof(struct S, c));
    printf("the double is at offset %zu\n", offsetof(struct S, d));
}
```

### Unions

A ```union``` is a variable that may hold (at different times) objects of different types and sizes, with the compiler keeping track of size and alignment requirements.

Unions provide a way to manipulate different kinds of data in a single area of storage, without embedding any machine-dependent information in the program.

The usage of union is consistent: the type retrieved must be the type most recently stored. It is the programmer's responsibility to keep track of which type is currently stored in a union; the results are implementation-dependent if something is stored as one type and extracted as another.

In effect, a union is a structure in which all members have offset zero from the base, the structure is big enough to hold the widest member, and the alignment is appropriate for all of the types in the union.

A union may only be initialized with a value of the type of its first member.

### Enums

### typedef

## Statements

The loop (```for```, ```while```, ```do..while```) is a powerful programming tool. You should pay particular attention to three aspects when setting up a loop:

* Clearly defining the condition that causes the loop to terminate.
* Making sure the values used in the loop test are initialized before the first use.
* Making sure the loop does something to update the test each cycle.

### if..else if..else

```
if (expression1)
{
    statements;
}
else if (expression2)
{
    statements;
}
else
{
    statements;
}
```

Because the *else* part of an *if-else* is optional, there is an ambiguity when an else if omitted from a nested *if* sequence. This is resolved by associating the *else* with the closest previous *else*-less *if*, such as:

```
if (n > 0)
    if (a > b)
        z = a;
    else
        z = b;
```

You can use the conditional expression ```expression1 ? expression2 : expression3``` when you have a variable to which you want to assign one of two possible values. A typical example is setting a variable equal to the maximum of two values:

```
max = (a > b) ? a : b;
```

### switch

The switch statement is a multi-way decision that tests whether an expression matches one of a number of constant integer values, and branches accordingly.

* All case expressions must be different.
* The case labeled *default* is executed if none of the other cases are satisfied. A *default* is optional; if it isn't there and if none of the cases match, no action at all takes place. Cases and the default clause can occur in any order.
* The *break* statement causes an immediate exit from the *switch*. Because cases serve just as labels, after the code for one case is done, execution *falls through* to the next unless you take explicit action to escape. *break* and *return* are the most common ways to leave a *switch*.
* As a matter of good form, put a *break* after the last case (the *default* here) even though it's logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.

```
switch (expr)
{
case const1:
    statements;
    break;
case const2:
    statements;
    break;
default:
    statements;
    break;
}
```

### for

```
for (expr1; expr2; expr3)
{
    statements;
}
```

### while

```
while (expr)
{
    statements;
}
```

### do..while

```
do
{
    statements;
}
while(expr);
```

* The *do-while* body is always executed at least once.

### break and continue

The *break* statement provides an early exit from *for*, *while*, *do-while* and *switch*. A *break* causes the innermost enclosing loop or *switch* to be exited immediately.

The *continue* statement causes the rest of an iteration to be skipped and the next iteration of the enclosing *for*, *while*, or *do-while* loop to be started.

* In the *while* and *do-while*, this means that the test part is executed immediately;
* In the *for*, control passes to the increment step.

The *continue* statement applies only to loops, not to *switch*. A *continue* inside a *switch* inside a loop causes the next loop iteration.

### goto and labels

* There are a few situations where *goto* may find a place. The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once (a single ```break``` gets you out of the innermost loop only).

* A label has the same form as a variable name, and is followed by a colon. It can be attached to any statement in the same function as the *goto*. **The scope of a label is the entire function**.

```
goto label;

...

label:
  statement
```

## Functions

* In C, all variables must be declared before they are used, usually at the beginning of the function before any executable statements.

```
return-type function-name(argument-declarations)
{
    declarations;
    statements;
}
```

Various parts may be absent:

* If the *return-type* is omitted, *int* is assumed.

A minimal function is

```
dummy() {}
```

which does nothing and returns nothing.

* If a function declaration does not include arguments, as in ```double atof();``` that is taken to mean that nothing is to be assumed about the arguments of *atof*; all parameter checking is turned off. This special meaning of the empty argument list is intended to permit older C programs to compile with new compilers. But it's a bad idea to use it with new C programs.

* If the function takes arguments, declare them; if it takes no arguments, use **void**.

### main()

```
int main(int argc, char *argv[])
{
    ...
}
```

* Normally you are at liberty to give functions whatever names you like, but ```main``` is special: your program begins executing at the beginning of **main**. This means that every program must have a **main** somewhere.
* ```argc``` is the number of command-line arguments the program was invoked with.
* ```argv``` is a pointer to an array of character strings that contain the arguments, one per string.
* By convention, ```argv[0]``` is the name by which the program was invoked, so ```argc``` is at least 1.

### External Variables

* External variables are defined outside of any function, and are thus potentionally available to many functions.
* Functions themselves are always external, because C does not allow functions to be defined inside other functions.
* By default, external variables and functions have the property that all references to them by the same name, even from functions compiled separately, are references to the same thing.

* External variables are also useful because of their greater scope and lifetime.
* The scope of an external variable or a function lasts from the point at which it is declared to the end of the file being compiled.
* If an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an *extern* declaration is mandatory.

* It is important to distinguish between the *declaration* of an external variable and its *definition*.
* There must be only one *definition* of an external variable among all the files that make up the source program; other files may contain extern declarations to access it.
* Array sizes must be specified with the *definition*, but are optional with an extern *declaration*.
* Initialization of an external variable goes only with the *definition*.

    * definition: ```double val[MAXVAL];```
    * declaration: ```extern double val[];```

* If a large number of variables must be shared among functions, external variables are more convenient and efficient than long argument lists. However, this reasoning should be applied with some caution, for it can have a bad effect on program structure, and lead to programs with too many data connections between functions.

* In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined initial values.
* For external and static variables, the initializer must be a constant expression. The initialization is done once, conceptionally before the program begins execution.
* For external and static variables, the initializer must be a constant expression.

### Static Variables

* The *static* declaration, applied to an *external variable* or *function*, limits the scope of that object to the rest of the source file being compiled.
* The *static* declaration can also be applied to *internal variables*. Internal static variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and going each time the function is activated. This means that internal static variables provide private, permanent storage within a single function.

* In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined initial values.
* For external and static variables, the initializer must be a constant expression.

### Automatic Variables


### Register Variables

* A *register* declaration advises the compiler that the variable in question will be heavily used. The idea is that *register* variables are to be placed in machine registers, which may result in smaller and faster programs. But compilers are free to ignore the advice.
* The *register* declaration can only be applied to *automatic variables* and to the formal parameters of a function.
* In practice, there are restrictions on register variables, reflecting the realities of underlying hardware.

    * Only a few variables in each function may be kept in registers, and only certain types are allowed. Excess register declarations are harmless, however, since the word register is ignored for excess or disallowed declarations.
    * It is not possible to take the address of a register variable, regardless of whether the variable is actually placed in a register.
    * The specific restrictions on number and types of register variables vary from machine to machine.

* In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined initial values.
* For automatic and register variables, the initializer is not restricted to being a constant: it may be any expression involving previously defined values, even function calls.

```
void func(unsigned m, register long n)
{
    register int i;
    ...
}
```

# C Libraries

## C Standard Library

Refer to [Standard C Complete Reference (from Plauger and Brodie)](http://cs.stmarys.ca/~porter/csc/ref/std_c/) and [C++ Standard Library (but no STL) Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_standlib.html).

The C standards committee publishes experimental C language and library extensions for future standardization. Refer to [Experimental C Standard Libraries](http://en.cppreference.com/w/c/experimental).

The C Standard Library header files are listed in following table. It also can be found [CppReference.com](http://en.cppreference.com/w/c/header).

| C Header              | Standard       | Note | Links |
| :-------------------- | :------------: | :--- | :---- |
| \<**assert.h**\>      |                | for enforcing assertions when functions execute | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/assert.html) [2](http://www.cplusplus.com/reference/cassert/) [3](http://en.cppreference.com/w/c/header) |
| \<**complex.h**\>     | since **C99**  | Complex number arithmetic | [1](http://en.cppreference.com/w/c/header) |
| \<**ctype.h**\>       |                | for classifying characters | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/ctype.html) [2](http://www.cplusplus.com/reference/cctype/) [3](http://en.cppreference.com/w/c/header) |
| \<**errno.h**\>       |                | for testing error codes reported by library functions | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/errno.html) [2](http://www.cplusplus.com/reference/cerrno/) [3](http://en.cppreference.com/w/c/header) |
| \<**fenv.h**\>        | since **C99**  | for accessing the floating-point environment | [1](http://www.cplusplus.com/reference/cfenv/) [2](http://en.cppreference.com/w/c/header) |
| \<**float.h**\>       |                | for testing floating-point type properties | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/float.html) [2](http://www.cplusplus.com/reference/cfloat/) [3](http://en.cppreference.com/w/c/header) |
| \<**inttypes.h**\>    | since **C99**  | Format conversion of integer types | [1](http://www.cplusplus.com/reference/cinttypes/) [2](http://en.cppreference.com/w/c/header) |
| \<**iso646.h**\>      | since **C95**  | for programming in ISO 646 variant character sets | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/iso646.html) [2](http://www.cplusplus.com/reference/ciso646/) [3](http://en.cppreference.com/w/c/header) |
| \<**limits.h**\>      |                | for testing integer type properties | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/limits.html) [2](http://www.cplusplus.com/reference/climits/) [3](http://en.cppreference.com/w/c/header) |
| \<**locale.h**\>      |                | for adapting to different cultural conventions | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/locale.html) [2](http://www.cplusplus.com/reference/clocale/) [3](http://en.cppreference.com/w/c/header) |
| \<**math.h**\>        |                | for computing common mathematical functions | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/math.html) [2](http://www.cplusplus.com/reference/cmath/) [3](http://en.cppreference.com/w/c/header) |
| \<**setjmp.h**\>      |                | for executing nonlocal *goto* statements | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/setjmp.html) [2](http://www.cplusplus.com/reference/csetjmp/) [3](http://en.cppreference.com/w/c/header) |
| \<**signal.h**\>      |                | for controlling various exceptional conditions | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/signal.html) [2](http://www.cplusplus.com/reference/csignal/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdalign.h**\>    | since **C11**  | alignas and alignof convenience macros | [2](http://en.cppreference.com/w/c/header) |
| \<**stdarg.h**\>      |                | for accessing a varying number of arguments | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/stdarg.html) [2](http://www.cplusplus.com/reference/cstdarg/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdatomic.h**\>   | since **C11**  | Atomic types | [1](http://en.cppreference.com/w/c/header) |
| \<**stdbool.h**\>     | since **C99**  | Boolean type | [1](http://www.cplusplus.com/reference/cstdbool/) [2](http://en.cppreference.com/w/c/header) |
| \<**stddef.h**\>      |                | for defining several useful types and macros | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/stddef.html) [2](http://www.cplusplus.com/reference/cstddef/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdint.h**\>      | since **C99**  | Fixed-width integer types | [1](http://www.cplusplus.com/reference/cstdint/) [2](http://www.cplusplus.com/reference/cstdint/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdio.h**\>       |                | for performing input and output | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/stdio.html) [2](http://www.cplusplus.com/reference/cstdio/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdlib.h**\>      |                | for general utilities: memory management, program utilities, string conversions, random numbers | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/stdlib.html) [2](http://www.cplusplus.com/reference/cstdlib/) [3](http://en.cppreference.com/w/c/header) |
| \<**stdnoreturn.h**\> | since **C11**  | noreturn convenience macros |  [2](http://en.cppreference.com/w/c/header) |
| \<**string.h**\>      |                | for manipulating several kinds of strings | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/string.html) [2](http://www.cplusplus.com/reference/cstring/) [3](http://en.cppreference.com/w/c/header) |
| \<**tgmath.h**\>      | since **C99**  | Type-generic math (macros wrapping **math.h** and **complex.h** | [1](http://www.cplusplus.com/reference/ctgmath/) [2](http://en.cppreference.com/w/c/header) |
| \<**threads.h**\>     | since **C11**  | Thread library |  [2](http://en.cppreference.com/w/c/header) |
| \<**time.h**\>        |                | for converting between various time and date formats | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/time.html) [2](http://www.cplusplus.com/reference/ctime/) [2](http://en.cppreference.com/w/c/header) |
| \<**uchar.h**\>       | since **C11**  | UTF-16 and UTF-32 character utilities | [1](http://www.cplusplus.com/reference/cuchar/) [2](http://en.cppreference.com/w/c/header) |
| \<**wchar.h**\>       | since **C95**  | for manipulating wide streams and several kinds of strings | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/wchar.html) [2](http://www.cplusplus.com/reference/cwchar/) [3](http://en.cppreference.com/w/c/header) |
| \<**wctype.h**\>      | since **C95**  | for classifying wide characters | [1](http://cs.stmarys.ca/~porter/csc/ref/std_c/wctype.html) [2](http://www.cplusplus.com/reference/cwctype/) [3](http://en.cppreference.com/w/c/header) |

<p/>

## Open Source C Libraries

Refer to [list of open source C libraries](http://en.cppreference.com/w/c/links/libs).

### GNU C Library (glibc)

# C Code Conventions

## MISRA C

MISRA (Motor Industry Software Reliability Association) was originally established as a collaboration between vehicle manufacturers, component suppliers and engineering consultancies, and seeks to promote best practice in developing safety-related electronic systems in road vehicles and other embedded systems. To this end MISRA publishes documents that provide accessible information for engineers and management, and holds events to permit the exchange of experiences between practitioners.

As part of these activities, **MISRA C** was first published in 1998. The intention was to provide a **restricted subset of a standardized structured language** as required in the 1994 MISRA Guidelines for automotive systems being developed to meet the requirements of Safety Integrity Level (SIL) 2 and above.

Since its launch in 1998, the uptake and usage of MISRA C has far exceeded the authors's original expectations. MISRA C was originally developed to support the language requirements of the 1994 MISRA Guidelines, as noted above. Since that time, however, MISRA C has been adopted and used across a wide variety of industries and applications including the rail, aerospace, military and medical sectors. Furthermore, a significant number of tools are available that support enforcing the MISRA C rules. In Japan, a Japanese translation of MISRA C has been published by **JSAE**, and the MISRA C Study Group have produced a book (in Japanese) giving detailed explanations of the rules and additional code examples.

Refer to [MISRA publications](https://www.misra.org.uk/Publications/tabid/57/Default.aspx) for more information.

### MISRA C:1998 (MISRA C1)

MISRA C:1998 (MISRA C1) is the original version of MISRA C. It remains available for legacy projects that need to refer to it, but MISRA C:2012 (see below) should be used for all new projects.

### MISRA C:2004 (MISRA C2)

A considerable amount of feedback on the original version of MISRA C was received and it was recognized that a revision was appropriate, in particular to address the following:

* Ensuring that the language used is consistent with the standard language
* Replacing generalized rules for Undefined Behaviour with specific rules targeted at Undefined Behaviour only
* Ensuring *one rule, one issue*; i.e. complex rules are split into atomic rules for ease of compliance
* Adding to and improving the code examples
* Removing the option for tool-less use

In updating MISRA C, the aim was to avoid new material and to ensure backwards compatibility with the earlier version (MISRA C1 / MISRA C:1998) where possible.

The second version of MISRA C is known as **MISRA C:2004** and is titled **Guidelines for the use of the C language in critical systems**.

In July 2007 an Exemplar Suite was released. This is a set of code examples that demonstrate conforming and non-conforming code for the majority of the MISRA C rules. This Exemplar Suite is of value to users both in understanding the rules and also in evaluating the performance of rule-checking tools, although in this respect it must be understood that the Exemplar Suite is not a conformance testing suite.

In July 2007 a Technical Corrigendum was also issued, giving updates based on some of the most commonly-asked questions and also issues identified during the development of the Exemplar Suite. When MISRA C:2004 was reprinted in June 2008, the opportunity was taken to incorporate the text of the Technical Corrigendum.

Refer to ![MISRA-C:2004](/docs/MISRA-C-2004.pdf) for details.

### MISRA C:2012 (MISRA C3)

MISRA C:2012 was published on 18 March 2013. MISRA C:2012 extends support to the **C99** version of the language whilst maintaining guidelines for C90. Other improvements, many of which have been made as a result of user feedback, include: better rationales for every guideline, identified decidability so users can better interpret the output of checking tools, greater granularity of rules to allow more precise control, a number of expanded examples and integration of MISRA AC AGC. A cross reference for ISO 26262 has also been produced.

## GNU Coding Standards

The GNU Coding Standards were written by Richard Stallman and other GNU Project volunteers. Their purpose is to make the GNU system clean, consistent, and easy to install. This document can also be read as a guide to writing portable, robust and reliable programs. It focuses on programs written in C, but many of the rules and principles are useful even if you write in another programming language. The rules often state reasons for writing in a certain way. Refer to [GNU Coding Standards](http://www.gnu.org/prep/standards/).

# C Compilers

![C_Compiler_and_Linker](/assets/C_Compiler_and_Linker.png)

## GCC (GNU Compiler Collection)

[The GNU Compiler Collection (GCC)](https://gcc.gnu.org/) includes front ends for C, C++, Objective-C, Fortran, Ada, and Go, as well as libraries for these languages (libstdc++, ...). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user's freedom.

## Clang

[Clang](http://clang.llvm.org/) is a compiler front end for the programming languages C, C++, Objective-C, Objective-C++, OpenMP, OpenCL, and CUDA. It uses [LLVM (Low Level Virtual Machine)](http://llvm.org/) as its back end and has been part of the LLVM release cycle since LLVM 2.6.

It is designed to be able to replace the full GNU Compiler Collection (GCC). Its contributors include Apple, Microsoft, Google, ARM, Sony, Intel and Advanced Micro Devices (AMD). It is open-source software, with source code released under the University of Illinois/NCSA License, a permissive free software licence.

The Clang project includes the Clang front end and the Clang static analyzer and several code analysis tools.

### Background

LLVM was intended originally to use GCC's front end, but GCC turned out to cause some problems for developers of LLVM and at Apple. The GCC source code is a large and somewhat cumbersome system for developers to work with; as one long-time GCC developer put it, *Trying to make the hippo dance is not really a lot of fun*.

Apple software makes heavy use of Objective-C, but the Objective-C front-end in GCC is a low priority for GCC developers. Also, GCC does not integrate smoothly into Apple's IDE. Finally, GCC is licensed under **GNU General Public License (GPL) version 3**, which requires developers who distribute extensions for, or modified versions of, GCC to make their source code available, whereas LLVM has a **BSD-like license** which does not force users to release their source code changes when publishing compiled binaries of those changes.

Apple chose to develop a new compiler front end from scratch, supporting C, Objective-C and C++. This **clang** project was open-sourced in July 2007.

## Coliru Online Compiler

[Coliru Online Compiler](http://coliru.stacked-crooked.com/)

# C IDE

## Dev-C++

## Visual Studio

[Visual Studio 2015: C/C++ Language and Standard Libraries](https://msdn.microsoft.com/en-us/library/hh875057.aspx)

# Books

* **The C Programming Language, 2nd edition**
* **C Primer**

# References

* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html">Linux: C/C++ Libraries</a>
* [C programming language on Wikipedia](https://en.wikipedia.org/wiki/C_%28programming_language%29)
* [C/C++ Reference](http://en.cppreference.com/w/)
* [cplusplus.com](http://www.cplusplus.com/)
* [Standard C](http://cs.stmarys.ca/~porter/csc/ref/std_c/)
* [Standard C Index](http://cs.stmarys.ca/~porter/csc/ref/std_c/_index.html)
* [MISRA C](https://www.misra-c.com/MISRAChome/tabid/181/Default.aspx)
* [GCC](https://gcc.gnu.org/)
* [Clang](http://clang.llvm.org/)
* [Clang on wikipedia](https://en.wikipedia.org/wiki/Clang)

* [Visual Studio 2015: C/C++ Language and Standard Libraries](https://msdn.microsoft.com/en-us/library/hh875057.aspx)
