---
layout: post
title: "C"
tag: Programming Languages
toc: true
---

This article introduces the **C** programming language.

<!--more-->

# Overview

The **C** programming language was developed in 1972 by *Dennis Ritchie* and *Brian Kernighan* at the AT&T Corporation for programming computer operating systems. Its capacity to structure data and programs through the composition of smaller units is comparable to that of ALGOL (Algorithmic Language). It uses a compact notation and provides the programmer with the ability to operate with the addresses of data as well as with their values. This ability is important in systems programming, and C shares with assembly language the power to exploit all the features of a computer’s internal architecture.

# C Standards

Refer to [C Standard Committee (ISO/IEC JTC1/SC22/WG14)](http://www.open-std.org/JTC1/SC22/WG14/www/standards):

![C Language Evolution](/assets/C_Language_Evolution.png)

* **K&R C**

    First edition of ***The C Programming Language*** published by **Brian Kernighan** and **Dennis Ritchie** in 1978. This book, known to C programmers as **K&R**, served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as **K&R C**.

* **ANSI X3.159-1989 (ANSI C, C89)**

    In 1983, the **American National Standards Institute (ANSI)** formed a committee, **X3J11**, to establish a standard specification of C. **X3J11** based the C standard on the Unix implementation; however, the non-portable portion of the Unix C library was handed off to the **IEEE working group 1003** to become the basis for the 1988 POSIX standard. In 1989, the C standard was ratified as **ANSI X3.159-1989** ***Programming Language C***. This version of the language is often referred to as **ANSI C**, **Standard C**, or sometimes **C89**.

* **ISO/IEC 9899:1990 (C90)**

    In 1990, the **ANSI C** standard (with formatting changes) was adopted by the International Organization for Standardization (ISO) [C Standard Committee (ISO/IEC JTC1/SC22/WG14 - C)](http://www.open-std.org/JTC1/SC22/WG14/www/standards) as **ISO/IEC 9899:1990**, which is sometimes called **C90**. Therefore, the terms **C89** and **C90** refer to the same programming language.

    It has since been amended three times by Technical Corrigenda (COR) or Amendment (AMD):

    * **ISO/IEC 9899:1990/AM1:1995** (known as **C90 AMD1** or **C95**)
    * **ISO/IEC 9899:1990/COR1:1995**
    * **ISO/IEC 9899:1990/COR2:1996**
     <p/>

* **ISO/IEC9899:1999 (C99)**

    The C standard was further revised in the late 1990s, leading to the publication of **ISO/IEC 9899:1999** in 1999, which is commonly referred to as **C99**.

    It has since been amended three times by Technical Corrigenda (COR):

    * **ISO/IEC 9899:1999/COR1:2001**
    * **ISO/IEC 9899:1999/COR2:2004**
    * **ISO/IEC 9899:1999/COR3:2007**
     <p/>

* **ISO/IEC 9899:2011 (C11)**

    In 2007, work began on another revision of the C standard, informally called **C1X** until its official publication on 2011-12-08. The C standards committee adopted guidelines to limit the adoption of new features that had not been tested by existing implementations. The **C11** standard adds numerous new features to C and the library, including type generic macros, anonymous structures, improved Unicode support, atomic operations, multi-threading, and bounds-checked functions. It also makes some portions of the existing **C99** library optional, and improves compatibility with C++.

    It has since been amended by Technical Corrigenda:

    * **ISO/IEC 9899:2011/COR1:2012**
     <p/>

* **Embedded C**

    Historically, embedded C programming requires nonstandard extensions to the C language in order to support exotic features. In 2008, the C Standards Committee published a technical report [TR 18037: Embedded C](/docs/ISO-IEC_TR_18037.pdf) extending the C language to address these issues by providing a common standard for all implementations to adhere to. It includes a number of features not available in normal C, such as fixed-point arithmetic, named address spaces, and basic I/O hardware addressing.

# C Language

## Phases of Translation

The C source file is processed by the compiler *as if* the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same. Refer to [Phases of translation](http://en.cppreference.com/w/c/language/translation_phases).

### Phase 1

* The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the *source character set*. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The *source character set* is a multibyte character set which includes the *basic source character set* as a single-byte subset, consisting of the following 96 characters:

    * 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)
    * 10 digit characters from ```0``` to ```9```
    * 52 letters from ```a``` to ```z``` and from ```A``` to ```Z```
    * 29 punctuation characters: ```_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’```
    <p/>

* **Trigraph sequences** are replaced by corresponding single-character representations.

| Primary | Trigraph  |
| :-----: | :-------: |
| ```{``` | ```??<``` |
| ```}``` | ```??>``` |
| ```[``` | ```??(``` |
| ```]``` | ```??)``` |
| ```#``` | ```??=``` |
| ```\``` | ```??/``` |
| ```^``` | ```??'``` |
| ```|``` | ```??!``` |
| ```~``` | ```??-``` |

<p/>

### Phase 2

* Whenever backslash ```\``` appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one.

* If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.

### Phase 3

* The source file is decomposed into comments, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and *preprocessing tokens*, which are the following

    * header names: ```<stdio.h>``` or ```"myfile.h"```
    * identifiers
    * numbers
    * character constants and string literals
    * operators and punctuators (including alternative tokens), such as ```+```, ```<<=```, ```<%```, ```##```, or ```and```
    * individual non-whitespace characters that do not fit in any other category
    <p/>

* Each comment is replaced by one space character.

* Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.

### Phase 4

* Preprocessor is executed.
* Each file introduced with the ```#include``` directive goes through **phases 1** through **4**, recursively.
* At the end of this phase, all preprocessor directives are removed from the source.

### Phase 5

* All characters and escape sequences in character constants and string literals are converted from *source character set* to *execution character set* (which may be a multibyte character set such as UTF-8, as long as all 96 characters from the *basic source character set* listed in **phase 1** have single-byte representations). If the character specified by an escape sequence isn't a member of the *execution character set*, the result is implementation-defined, but is guaranteed to not be a null (wide) character.

    Note: the conversion performed at this stage can be controlled by command line options in some implementations: *gcc* and *clang* use ```-finput-charset``` to specify the encoding of the source character set, ```-fexec-charset``` and ```-fwide-exec-charset``` to specify the encodings of the *execution character set* in the string and character literals that don't have an encoding prefix (since **C11**).

### Phase 6

* Adjacent string literals are concatenated.

### Phase 7

* Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a **translation unit**.

### Phase 8

* Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).

## Keywords

This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.

| Keywords | Standard  |
| :------- | :-------- |
| auto     | since C89 |
| break    | since C89 |
| case     | since C89 |
| char     | since C89 |
| const    | since C89 |
| continue | since C89 |
| default  | since C89 |
| do       | since C89 |
| double   | since C89 |
| else     | since C89 |
| enum     | since C89 |
| extern   | since C89 |
| float    | since C89 |
| for      | since C89 |
| goto     | since C89 |
| if       | since C89 |
| inline   | since **C99** |
| int      | since C89 |
| long     | since C89 |
| register | since C89 |
| restrict | since C99 |
| return   | since C89 |
| short    | since C89 |
| signed   | since C89 |
| sizeof   | since C89 |
| static   | since C89 |
| struct   | since C89 |
| switch   | since C89 |
| typedef  | since C89 |
| union    | since C89 |
| unsigned | since C89 |
| void     | since C89 |
| volatile | since C89 |
| while    | since C89 |
| _Alignas | since **C11** |
| _Alignof | since **C11** |
| _Atomic  | since **C11** |
| _Bool    | since **C99** |
| _Complex | since **C99** |
| _Generic | since **C11** |
| _Imaginary | since **C99** |
| _Noreturn  | since **C11** |
| _Static_assert | since **C11** |
| _Thread_local  | since **C11** |

<p/>

Most of the recently reserved words begin with an underscore followed by a capital letter, because identifiers of that form were previously reserved by the C standard for use only by implementations. Since existing program source code should not have been using these identifiers, it would not be affected when C implementations started supporting these extensions to the programming language. Some standard headers do define more convenient synonyms for underscored identifiers. The language previously included a reserved word called *entry*, but this was seldom implemented, and has now been removed as a reserved word.

## Operators

| Operators                                               | Associativity     | Description |
| :------------------------------------------------------ | :---------------: | :---------- |
| `()` `[]` `->` `.` `::`                                 | left to right     | Function call, scope, array/member access |
| `!` `~` `++` `--` `+` `-` `(type)` `*` `&` `sizeof`     | **right to left** | Unary operators, sizeof and type casts |
| `*` `/` `%`                                             | left to right     | Multiplication, division, modulo |
| `+` `-`                                                 | left to right     | Addition and subtraction |
| `<<` `>>`                                               | left to right     | Bitwise shift left and right |
| `<` `<=` `>` `>=`                                       | left to right     | Comparisons: less-than, ... |
| `==` `!=`                                               | left to right     | Comparisons: equal and not equal |
| `&`                                                     | left to right     | Bitwise AND |
| `^`                                                     | left to right     | Bitwise exclusive OR (XOR) |
| `|`                                                     | left to right     | Bitwise inclusive (normal) OR |
| `&&`                                                    | left to right     | Logical AND |
| `||`                                                    | left to right     | Logical OR |
| `?:`                                                    | **right to left** | Conditional expression (ternary) |
| `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `|=` | **right to left** | Assignment operators |
| `,`                                                     | left to right     | Comma operator |

<p/>

Run the following command to get the operator priority under Linux environment:

    chenwx@chenwx ~ $ man operator

    NAME
           operator - C operator precedence and order of evaluation

    DESCRIPTION
           This manual page lists C operators and their precedence in evaluation.

           Operator                             Associativity
           () [] -> .                           left to right
           ! ~ ++ -- + - (type) * & sizeof      right to left
           * / %                                left to right
           + -                                  left to right
           << >>                                left to right
           < <= > >=                            left to right
           == !=                                left to right
           &                                    left to right
           ^                                    left to right
           |                                    left to right
           &&                                   left to right
           ||                                   left to right
           ?:                                   right to left
           = += -= *= /= %= <<= >>= &= ^= |=    right to left
           ,                                    left to right

    COLOPHON
           This page is part of release 3.54 of the Linux man-pages project.  A description of the project, and information about reporting bugs, can befound at http://www.kernel.org/doc/man-pages/.

## Comments

**C-style comments** or **multi-line comments**

```
/* comment */
```

**C++-style comments** or **single-line comments** (since **C99**)

```
// comment until end of the line
```

## Preprocessor

The preprocessor is executed at [translation phase 4](#phases-of-translation), before the compilation. The result of preprocessing is single file which is then passed to the actual compiler. Refer to [Preprocessor](http://en.cppreference.com/w/c/preprocessor).

The preprocessor has the source file translation capabilities:

* Conditionally compile of parts of source file: ```#if```, ```#ifdef```, ```#ifndef```, ```#else```, ```#elif``` and ```#endif```
* Replace text macros while possibly concatenating or quoting identifiers: ```#define``` and ```#undef```, and operators ```#``` and ```##```
* Include other files: ```#include```
* Cause an error: ```#error```

The following aspects of the preprocessor can be controlled:

* Implementation defined behavior: ```#pragma``` and operator ```_Pragma``` (since C99)
* File name and line information available to the preprocessor: ```#line```

NOTE: Those preprocessor directives are defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive ```#warning``` which emits a user-defined message during compilation.

The output of preprocessing of source file *example.c* to file *example.l*:

```
gcc -E -o example.l example.c
```

## Escape Sequences

Escape sequences are used to represent certain special characters within string literals and character constants. The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:

| Escape sequence  |      Description      | Representation |
| :--------------- | :-------------------- | :------------- |
| ```\'```         | single quote          | byte 0x27 (in ASCII encoding) |
| ```\"```         | double quote          | byte 0x22 (in ASCII encoding) |
| ```\?```         | question mark         | byte 0x3f (in ASCII encoding) |
| ```\\```         | backslash             | byte 0x5c (in ASCII encoding) |
| ```\a```         | audible bell          | byte 0x07 (in ASCII encoding) |
| ```\b```         | backspace             | byte 0x08 (in ASCII encoding) |
| ```\f```         | form feed / new page  | byte 0x0c (in ASCII encoding) |
| ```\n```         | line feed / new line  | byte 0x0a (in ASCII encoding) |
| ```\r```         | carriage return       | byte 0x0d (in ASCII encoding) |
| ```\t```         | horizontal tab        | byte 0x09 (in ASCII encoding) |
| ```\v```         | vertical tab          | byte 0x0b (in ASCII encoding) |
| ```\nnn```       | arbitrary octal value | byte nnn |
| ```\xnn```       | arbitrary hexadecimal value | byte nn |
| ```\unnnn```     | Unicode character that is not in the basic character set. May result in several characters. | code point U+nnnn |
| ```\Unnnnnnnn``` | Unicode character that is not in the basic character set. May result in several characters. | code point U+nnnnnnnn |

<p/>

* The escape sequence represents only a single character.
* The escape sequences provides a general and extensible mechanism for representing hard-to-type or invisible characters.

## Data Types

### Fundamental Types

The C language provides the four basic arithmetic type specifiers **char**, **int**, **float** and **double**, and the modifiers **signed**, **unsigned**, **short** and **long**. The following table lists the permissible combinations to specify a large set of storage size-specific declarations. Refer to [C Data Types](https://en.wikipedia.org/wiki/C_data_types).

Each compiler is free to choose appropriate sizes for its own hardware, subject only to the the restriction that *short*s and *int*s are at least 16 bits, *long*s are at least 32 bits, and *short* is no longer than *int*, which is no longer than *long*.

* **char**

| Standard         | since **C89** |
| Format Specifier | ```%c``` |
| Size             | It is **at least 8 bits** (**CHAR_BIT** bits) in size. |
| Explanation      | Smallest addressable unit of the machine that can contain basic character set. It is an *integer* type. **Actual type can be either signed or unsigned depending on the implementation**. |
| Constants        | A character constant is an integer, written as one character within single quotes, such as 'x'. |

<p/>

* **signed char**

| Standard         | since **C89** |
| Format Specifier | ```%c``` (or ```%hhi``` for numerical output) |
| Size             | It is **at least 8 bits** (**CHAR_BIT** bits) in size. |
| Explanation      | Of the same size as **char**, but guaranteed to be signed. |
| Constants        | |

<p/>

* **unsigned char**

| Standard         | since **C89** |
| Format Specifier | ```%c``` (or ```%hhu``` for numerical output) |
| Size             | It is **at least 8 bits** (**CHAR_BIT** bits) in size. |
| Explanation      | Of the same size as **char**, but guaranteed to be unsigned. It is represented in binary notation without padding bits; thus, its range is exactly [0, 2^CHAR_BIT - 1]. |
| Constants        | |

<p/>

* **short** / short int / signed short / signed short int

| Standard         | since **C89** |
| Format Specifier | ```%hi``` |
| Size             | It is **at least 16 bits** in size. |
| Explanation      | Short signed integer type. |
| Constants        | |

<p/>

* **unsigned short** / unsigned short int

| Standard         | since **C89** |
| Format Specifier | ```%hu``` |
| Size             | It is **at least 16 bits** in size. |
| Explanation      | Similar to **short**, but unsigned. |
| Constants        | |

<p/>

* **int** / signed / signed int

| Standard         | since **C89** |
| Format Specifier | ```%i``` or ```%d``` |
| Size             | It is **at least 16 bits** in size. |
| Explanation      | Basic signed integer type. |
| Constants        | A int constant is written without suffix, as 1234, 02322, 0x4D2. |

<p/>

* **unsigned** / unsigned int

| Standard         | since **C89** |
| Format Specifier | ```%u``` |
| Size             | It is **at least 16 bits** in size. |
| Explanation      | Similar to **int**, but unsigned. |
| Constants        | An unsigned int constant is written with a terminal ```u``` or ```U```, as 1234U, 02322U, 0x4D2U. |

<p/>

* **long** / long int / signed long / signed long int

| Standard         | since **C89** |
| Format Specifier | ```%li``` or ```%ld``` |
| Size             | It is **at least 32 bits** in size. |
| Explanation      | Long signed integer type. |
| Constants        | A long constant is written with a terminal ```l``` or ```L```, as in 1234L, 02322L, 0x4D2L. |

<p/>

* **unsigned long** / unsigned long int

| Standard         | since **C89** |
| Format Specifier | ```%lu``` |
| Size             | It is **at least 32 bits** in size. |
| Explanation      | Similar to **long**, but unsigned. |
| Constants        | A unsigned long constant is written with a terminal ```ul``` or ```UL```, as in 1234UL, 02322UL, 0x4D2UL.

<p/>

* **long long** / long long int / signed long long / signed long long int

| Standard         | since **C99** |
| Format Specifier | ```%lli``` or ```%lld``` |
| Size             | It is **at least 64 bits** in size. |
| Explanation      | Long long signed integer type. |
| Constants        | |

<p/>

* **unsigned long long** / unsigned long long int

| Standard         | since **C99** |
| Format Specifier | ```%llu``` |
| Size             | It is **at least 64 bits** in size. |
| Explanation      | Similar to **long long**, but unsigned. |
| Constants        | |

<p/>

* **float**

| Standard         | since **C89** |
| Format Specifier | ```%f```, promoted automatically to **double** for printf() |
| Size             | |
| Explanation      | Real floating-point type, usually referred to as a single-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the **IEEE 754 single-precision binary floating-point format**. This format is required by the optional **Annex F: IEC 60559 floating-point arithmetic**. |
| Constants        | An float constant is written with a terminal ```f``` or ```F```, as 123.4F. |

<p/>

**double**

| Standard         | since **C89** |
| Format Specifier | ```%f``` or ```%F``` (For scanf(): ```%lf``` or ```%lF```. For scientific notation: ```%g``` or ```%G```, ```%e``` or ```%E``` ) |
| Size             | |
| Explanation      | Real floating-point type, usually referred to as a double-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the **IEEE 754 double-precision binary floating-point format**. This format is required by the optional **Annex F: IEC 60559 floating-point arithmetic**. |
| Constants        | An double constant is written without suffix, as 123.4. |

<p/>

* **long double**

| Standard         | since **C89** |
| Format Specifier | ```%Lf``` or ```%LF``` (For scientific notation: ```%Lg``` or ```%LG```, ```%Le``` or ```%LE```) |
| Size             | |
| Explanation      | Real floating-point type, usually mapped to an extended precision floating-point number format. Actual properties unspecified. Unlike types **float** and **double**, it can be either 80-bit floating point format, the non-IEEE **double-double** or **IEEE 754 quadruple-precision floating-point format** if a higher precision format is provided, otherwise it is the same as double. |
| Constants        | An float constant is written with a terminal ```l``` or ```L```, as 123.4L. |

<p/>

### Derived Types

#### Arrays

#### Pointers

#### Structures

#### Unions

#### Enums

## Macros

* There is no semicolon at the end of a ```#define``` line.

## Functions

* In C, all variables must be declared before they are used, usually at the beginning of the function before any executable statements.

### main()

* Normally you are at liberty to give functions whatever names you like, but ```main``` is special: your program begins executing at the beginning of **main**. This means that every program must have a **main** somewhere.

## Flow Control Statements

### if

```
if (expr1)
{
    statements;
}
else if (expr2)
{
    statements;
}
else
{
    statements;
}
```

### for

```
for (expr1; expr2; expr3)
{
    statements;
}
```

### while

```
while (expr)
{
    statements;
}
```

### do..while

```
do
{
    statements;
}
while(expr);
```

### switch

```
switch (expr)
{
case const1:
    statements;
    break;
case const2:
    statements;
    break;
default:
    statements;
}
```

# C Libraries

## C Standard Library

Refer to the following links for C standard library:

* [C Standard Library Header Files](http://en.cppreference.com/w/c/header)
* [Online References of C/C++ Language & Libraries](http://chenweixiang.github.io/2015/12/18/linux-series-05-libraries.html#online-references-of-cc-language--libraries)
* [Experimental C Standard Libraries](http://en.cppreference.com/w/c/experimental)

And refer to the following links for types, macros and functions defined in the C standard library:

* [Type support](http://en.cppreference.com/w/c/types)
* [Dynamic memory management](http://en.cppreference.com/w/c/memory)
* [Error handling](http://en.cppreference.com/w/c/error)
* [Program utilities](http://en.cppreference.com/w/c/program)
* [Variadic functions](http://en.cppreference.com/w/c/variadic)
* [Date and time utilities](http://en.cppreference.com/w/c/chrono)
* [Strings library](http://en.cppreference.com/w/c/string)
* [Algorithms](http://en.cppreference.com/w/c/algorithm)
* [Numerics](http://en.cppreference.com/w/c/numeric)
* [File input/output](http://en.cppreference.com/w/c/io)
* [Localization support](http://en.cppreference.com/w/c/locale)
* [Atomic operations library](http://en.cppreference.com/w/c/atomic)

## Open Source C Libraries

Refer to [list of open source C libraries](http://en.cppreference.com/w/c/links/libs).

# C Code Conventions

## MISRA C

MISRA (Motor Industry Software Reliability Association) was originally established as a collaboration between vehicle manufacturers, component suppliers and engineering consultancies, and seeks to promote best practice in developing safety-related electronic systems in road vehicles and other embedded systems. To this end MISRA publishes documents that provide accessible information for engineers and management, and holds events to permit the exchange of experiences between practitioners.

As part of these activities, **MISRA C** was first published in 1998. The intention was to provide a **restricted subset of a standardized structured language** as required in the 1994 MISRA Guidelines for automotive systems being developed to meet the requirements of Safety Integrity Level (SIL) 2 and above.

Since its launch in 1998, the uptake and usage of MISRA C has far exceeded the authors's original expectations. MISRA C was originally developed to support the language requirements of the 1994 MISRA Guidelines, as noted above. Since that time, however, MISRA C has been adopted and used across a wide variety of industries and applications including the rail, aerospace, military and medical sectors. Furthermore, a significant number of tools are available that support enforcing the MISRA C rules. In Japan, a Japanese translation of MISRA C has been published by **JSAE**, and the MISRA C Study Group have produced a book (in Japanese) giving detailed explanations of the rules and additional code examples.

Refer to [MISRA publications](https://www.misra.org.uk/Publications/tabid/57/Default.aspx) for more information.

### MISRA C:1998 (MISRA C1)

MISRA C:1998 (MISRA C1) is the original version of MISRA C. It remains available for legacy projects that need to refer to it, but MISRA C:2012 (see below) should be used for all new projects.

### MISRA C:2004 (MISRA C2)

A considerable amount of feedback on the original version of MISRA C was received and it was recognized that a revision was appropriate, in particular to address the following:

* Ensuring that the language used is consistent with the standard language
* Replacing generalized rules for Undefined Behaviour with specific rules targeted at Undefined Behaviour only
* Ensuring *one rule, one issue*; i.e. complex rules are split into atomic rules for ease of compliance
* Adding to and improving the code examples
* Removing the option for tool-less use

In updating MISRA C, the aim was to avoid new material and to ensure backwards compatibility with the earlier version (MISRA C1 / MISRA C:1998) where possible.

The second version of MISRA C is known as **MISRA C:2004** and is titled **Guidelines for the use of the C language in critical systems**.

In July 2007 an Exemplar Suite was released. This is a set of code examples that demonstrate conforming and non-conforming code for the majority of the MISRA C rules. This Exemplar Suite is of value to users both in understanding the rules and also in evaluating the performance of rule-checking tools, although in this respect it must be understood that the Exemplar Suite is not a conformance testing suite.

In July 2007 a Technical Corrigendum was also issued, giving updates based on some of the most commonly-asked questions and also issues identified during the development of the Exemplar Suite. When MISRA C:2004 was reprinted in June 2008, the opportunity was taken to incorporate the text of the Technical Corrigendum.

Refer to ![MISRA-C:2004](/docs/MISRA-C-2004.pdf) for details.

### MISRA C:2012 (MISRA C3)

MISRA C:2012 was published on 18 March 2013. MISRA C:2012 extends support to the **C99** version of the language whilst maintaining guidelines for C90. Other improvements, many of which have been made as a result of user feedback, include: better rationales for every guideline, identified decidability so users can better interpret the output of checking tools, greater granularity of rules to allow more precise control, a number of expanded examples and integration of MISRA AC AGC. A cross reference for ISO 26262 has also been produced.

## GNU Coding Standards

The GNU Coding Standards were written by Richard Stallman and other GNU Project volunteers. Their purpose is to make the GNU system clean, consistent, and easy to install. This document can also be read as a guide to writing portable, robust and reliable programs. It focuses on programs written in C, but many of the rules and principles are useful even if you write in another programming language. The rules often state reasons for writing in a certain way. Refer to [GNU Coding Standards](http://www.gnu.org/prep/standards/).

# C Compilers

## GCC (GNU Compiler Collection)

[The GNU Compiler Collection (GCC)](https://gcc.gnu.org/) includes front ends for C, C++, Objective-C, Fortran, Ada, and Go, as well as libraries for these languages (libstdc++, ...). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user's freedom.

## Coliru Online Compiler

[Coliru Online Compiler](http://coliru.stacked-crooked.com/)

# Development Environment

# Books

* **The C Programming Language, 2nd edition**
* **C Primer**

# References

* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html">Linux: C/C++ Libraries</a>
* [C programming language on Wikipedia](https://en.wikipedia.org/wiki/C_%28programming_language%29)
* [C/C++ Reference](http://en.cppreference.com/w/)
* [MISRA C](https://www.misra-c.com/MISRAChome/tabid/181/Default.aspx)
* [GCC](https://gcc.gnu.org/)
