---
layout: post
title: "Java"
tag: Programming Language
toc: true
---

This article introduces the **Java** programming language.

<!--more-->

# Brief Introduction

Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. It is intended to let application developers **write once, run anywhere (WORA)**, meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any **Java virtual machine (JVM)** regardless of computer architecture. As of 2016, Java is one of the most popular programming languages in use, particularly for client-server web applications, with a reported 9 million developers. Java was originally developed by **James Gosling** at *Sun Microsystems* (which has since been acquired by *Oracle Corporation*) and released in 1995 as a core component of Sun Microsystems' Java platform. The language derives much of its syntax from **C** and **C++**, but it has fewer low-level facilities than either of them. Refer to [Java Overview](http://www.oracle.com/technetwork/java/javase/overview/index.html) for more information.

## Java History

| Date | Description |
| :--- | :---------- |
| 1995年5月23日 | Java语言诞生 |
| 1996年1月 | 第一个JDK-JDK1.0诞生 |
| 1996年4月 | 10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 |
| 1996年9月 | 约8.3万个网页应用了JAVA技术来制作 |
| 1997年2月18日 | JDK1.1发布 |
| 1997年4月2日 | JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 |
| 1997年9月 | JavaDeveloperConnection社区成员超过十万 |
| 1998年2月 | JDK1.1被下载超过2,000,000次 |
| 1998年12月8日 | JAVA2企业平台J2EE发布 |
| 1999年6月 | SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME） |
| 2000年5月8日 | JDK1.3发布 |
| 2000年5月29日 | JDK1.4发布 |
| 2001年6月5日 | NOKIA宣布，到2003年将出售1亿部支持Java的手机 |
| 2001年9月24日 | J2EE1.3发布 |
| 2002年2月26日 | J2SE1.4发布，自此Java的计算能力有了大幅提升 |
| 2004年9月30日 | J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 |
| 2005年6月 | JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字2：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME |
| 2006年12月 | SUN公司发布JRE6.0 |
| 2009年12月 | SUN公司发布Java EE 6 |
| 2010年11月 | 由于Oracle公司对于Java社区的不友善，因此Apache扬言将退出JCP |
| 2011年7月28日 | Oracle公司发布Java SE 7 |
| 2014年3月18日 | Oracle公司发表Java SE 8 |

<p/>

## Java Principles

There were five primary goals in the creation of the Java language:

* It must be **simple, object-oriented, and familiar**.
* It must be **robust and secure**.
* It must be **architecture-neutral and portable**.
* It must execute with **high performance**.
* It must be **interpreted, threaded, and dynamic**.

## Java Versions

As of 2015, only **Java 8** is officially supported. Here is major release versions of Java, along with their release dates. Refer to [Java version history](https://en.wikipedia.org/wiki/Java_version_history).

| Java Version | Internal Version | Release_Date | Codename   | Classes | Packages |
| :----------- | :--------------: | :----------: | :--------- | :-----: | :------: |
| JDK 1.0      | 1.0.0            | Jan 23, 1996 |            | 212     | 8        |
| JDK 1.1      | 1.1.0            | Feb 19, 1997 |            | 504     | 23       |
| J2SE 1.2     | 1.2.0            | Dec 08, 1998 | Playground | 1520    | 59       |
| J2SE 1.3     | 1.3.0            | May 08, 2000 | Kestrel    | 1842    | 76       |
| J2SE 1.4     | 1.4.0            | Feb 06, 2002 | Merlin     | 2991    | 135      |
| J2SE 5.0     | 1.5.0            | Sep 30, 2004 | Tiger      | 3279    | 166      |
| Java SE 6    | 1.6.0            | Dec 11, 2006 | Mustang    | 3793    | 203      |
| Java SE 7    | 1.7.0            | Jul 28, 2011 | Dolphin    | 4024    | 209      |
| Java SE 8    | 1.8.0            | Mar 18, 2014 |            | 4240    | 217      |

<p/>

Since **J2SE 1.4**, the evolution of the Java language has been governed by the [**Java Community Process (JCP)**](#java-community-process), which uses **Java Specification Requests (JSRs)** to propose and specify additions and changes to the Java platform. The language is specified by the **Java Language Specification (JLS)**; changes to the JLS are managed under [JSR 901](https://www.jcp.org/en/jsr/detail?id=901).

## Java Community Process

The **Java Community Process (JCP)**, established in 1998, is a formalized mechanism that allows interested parties to develop standard technical specifications for Java technology. Anyone can become a JCP Member by filling a form available at the [JCP website](https://www.jcp.org/). JCP membership for organizations and commercial entities requires annual fees but is free for individuals.

The JCP involves the use of **Java Specification Requests (JSRs)** the formal documents that describe proposed specifications and technologies for adding to the Java platform. Formal public reviews of JSRs take place before a JSR becomes *final* and the *JCP Executive Committee* votes on it. A final JSR provides a *reference implementation* that is a free implementation of the technology in source code form and a Technology Compatibility Kit to verify the API specification.

A JSR describes the JCP itself. As of 2009, [JSR 215](https://www.jcp.org/en/jsr/detail?id=215) describes the current version (2.7) of the JCP.

List of JSRs:

* [List of all JSRs rated final](https://www.jcp.org/en/jsr/stage?listBy=final)
* [List of all JSRs](https://www.jcp.org/en/jsr/all)

Refer to [Java Language and Virtual Machine Specifications](http://docs.oracle.com/javase/specs/index.html):

* [The Java Language Specification - Java SE 8 Edition](http://docs.oracle.com/javase/specs/jls/se8/html/index.html)
* [The Java Virtual Machine Specification - Java SE 8 Edition](http://docs.oracle.com/javase/specs/jvms/se8/html/index.html)

# Setup Java Development Environment

## Java Development on Windows

1) Download JDK from the [Oracle site](http://www.oracle.com/technetwork/java/javase/downloads/index.html) and install it. Or you can download **NetBeans with JDK 8** directly if you like **NetBeans IDE** more.

2) Setup environment variables: JAVA_HOME, CLASSPATH, Path

After JDK installation finished, right click **My Computer** and select **Properties**, then click **Advanced System Settings** on the left-side tree, and **System Properties** window is opened, then click **Environment Variables** and add the following three new properties if it's not existed yet; otherwise, edit them.

| Name  | Value |
| :---- | :---- |
| JAVA_HOME | C:\Program Files\Java\jdk1.8.0_121 |
| CLASSPATH | .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; |
| Path | %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; |

<p/>

After the above configuration, you can check the Java SDK installation with command:

```
C:\Users\ewaadex>java -version
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b15)
Java HotSpot(TM) Client VM (build 25.45-b02, mixed mode)
```

3) Install IDE for Java: [Eclipse IDE for Java Developers](http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/neon2) or [NetBeans IDE](https://netbeans.org/index.html).

## Java Development on Linux

1) Download JDK from the [Oracle site](http://www.oracle.com/technetwork/java/javase/downloads/index.html) and install it. Or you can download **NetBeans with JDK 8** directly if you like **NetBeans IDE** more.

2) Setup environment variables: JAVA_HOME, CLASSPATH, PATH

```
~ $ vim /etc/profile

export JAVA_HOME=/opt/software/java/jdk_1.7.0_60
export JRE_HOME=/opt/software/java/jdk_1.7.0_60/jre
export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin

~ $ source /etc/profile
```

After the above configuration, you can check the Java SDK installation with command:

```
esekilxv8640 [4:29] [/home/ewaadex] -> java -version
java version "1.6.0_22"
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) 64-Bit Server VM (build 17.1-b03, mixed mode)
```

3) Install IDE for Java: [Eclipse IDE for Java Developers](http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/neon2) or [NetBeans IDE](https://netbeans.org/index.html).

# Java Plantform SE

## Java Plantform SE Architecture

The following conceptual diagram illustrates the components of Oracle's **Java SE** products, refer to [Java Platform Standard Edition 8 Documentation](http://docs.oracle.com/javase/8/docs/):

![Java SE 8 Conceptual Diagram](/assets/JavaSE8_Conceptual_Diagram.png)

Oracle has two software products that implement **Java Platform Standard Edition (Java SE) 8**:

* **Java SE Runtime Environment (JRE) 8**

    The **JRE** provides the libraries, [Java Virtual Machine (JVM)](#java-virtual-machine-jvm), and other components necessary for you to ***run*** applets and applications written in the Java programming language. *This runtime environment can be redistributed with applications to make them free-standing*. Note that the **JRE** includes components not required by the [Java SE specification](http://docs.oracle.com/javase/specs/jls/se8/html/index.html), including both standard and non-standard Java components.

* **Java SE Development Kit (JDK) 8**

    The **JDK** is a superset of **JRE**, and contains everything that is in **JRE**, plus command-line development tools such as compilers and debuggers that are necessary or useful for ***developing*** applets and applications.

## Java Virtual Machine (JVM)

A [**Java virtual machine (JVM)**](https://en.wikipedia.org/wiki/Java_virtual_machine) is an abstract computing machine that enables a computer to run a Java program. There are three notions of the JVM: *specification*, *implementation*, and *instance*. The *specification* is a document that formally describes what is required of a JVM implementation. Having a single specification ensures all implementations are interoperable. A JVM *implementation* is a computer program that meets the requirements of the JVM specification. An *instance* of a JVM is an implementation running in a process that executes a computer program compiled into Java bytecode.

**Java Runtime Environment (JRE)** is a software package that contains what is required to run a Java program. It includes a Java Virtual Machine implementation together with an implementation of the Java Class Library. The Oracle Corporation, which owns the Java trademark, distributes a Java Runtime environment with their Java Virtual Machine called [HotSpot](http://openjdk.java.net/groups/hotspot/).

**Java Development Kit (JDK)** is a superset of a JRE and contains tools for Java programmers, e.g. a javac compiler. The Java Development Kit is provided free of charge either by Oracle Corporation directly, or by the [OpenJDK](#openjdk) open source project, which is governed by Oracle.

Refer to [The Java Virtual Machine Specification - Java SE 8 Edition](http://docs.oracle.com/javase/specs/jvms/se8/html/index.html).

![Overview of Java virtual machine (JVM) architecture based on Java SE 7](/assets/JvmSpec7.png)

The JDK provides one or more implementations of the Java virtual machine (VM), refer to [Java Virtual Machine Technology](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html):

* On platforms typically used for client applications, the JDK comes with a VM implementation called the **Java HotSpot Client VM** (*client VM*). The *client VM* is tuned for reducing start-up time and memory footprint. It can be invoked by using the ```-client``` command-line option when launching an application.

* On all platforms, the JDK comes with an implementation of the Java virtual machine called the **Java HotSpot Server VM** (*server VM*). The *server VM* is designed for maximum program execution speed. It can be invoked by using the ```-server``` command-line option when launching an application.

## Java SE Packages

Refer to [Java Versions](#java-versions) for the numbers of classes and packages in each Java SE release.

### Java Bootstrap Packages

***Text Conventions***:

* **java.packageName**: Fundamental classes in Java, refer to [Java Fundamental Classes Reference](https://www.cs.ait.ac.th/~on/O/oreilly/java/fclass/index.htm) and [Fundamental Classes in Java](#fundamental-classes-in-java).
* ***java.awt***: Abstract Window Toolkit (AWT) in Java, refer to *Java AWT Reference*.

**Java SE 8** has the following packages, refer to [Java Platform, Standard Edition 8 API Specification](http://docs.oracle.com/javase/8/docs/api/).

| Packages | Description |
| :------- | :---------- |
| java.applet | Provides the classes necessary to create an applet and the classes an applet uses to communicate with its applet context. |
| ***java.awt*** | Contains all of the classes for creating user interfaces and for painting graphics and images. |
| java.awt.color | Provides classes for color spaces. |
| java.awt.datatransfer | Provides interfaces and classes for transferring data between and within applications. |
| java.awt.dnd | Drag and Drop is a direct manipulation gesture found in many Graphical User Interface systems that provides a mechanism to transfer information between two entities logically associated with presentation elements in the GUI. |
| java.awt.event | Provides interfaces and classes for dealing with different types of events fired by AWT components. |
| java.awt.font | Provides classes and interface relating to fonts. |
| java.awt.geom | Provides the Java 2D classes for defining and performing operations on objects related to two-dimensional geometry. |
| java.awt.im | Provides classes and interfaces for the input method framework. |
| java.awt.im.spi | Provides interfaces that enable the development of input methods that can be used with any Java runtime environment. |
| java.awt.image | Provides classes for creating and modifying images. |
| java.awt.image.renderable | Provides classes and interfaces for producing rendering-independent images. |
| java.awt.print | Provides classes and interfaces for a general printing API. |
| java.beans | Contains classes related to developing *beans* -- components based on the JavaBeans architecture. |
| java.beans.beancontext | Provides classes and interfaces relating to bean context. |
| **java.io** | Provides for system input and output through data streams, serialization and the file system. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| **java.lang** | Provides classes that are fundamental to the design of the Java programming language. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| java.lang.annotation | Provides library support for the Java programming language annotation facility. |
| java.lang.instrument | Provides services that allow Java programming language agents to instrument programs running on the JVM. |
| java.lang.invoke | Contains dynamic language support provided directly by the Java core class libraries and virtual machine. |
| java.lang.management | Provides the management interfaces for monitoring and management of the Java virtual machine and other components in the Java runtime. |
| java.lang.ref | Provides reference-object classes, which support a limited degree of interaction with the garbage collector. |
| **java.lang.reflect** | Provides classes and interfaces for obtaining reflective information about classes and objects. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| **java.math** | Provides classes for performing arbitrary-precision integer arithmetic (BigInteger) and arbitraryprecision decimal arithmetic (BigDecimal). Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| **java.net** | Provides the classes for implementing networking applications. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| java.nio | Defines buffers, which are containers for data, and provides an overview of the other NIO packages. |
| java.nio.channels | Defines channels, which represent connections to entities that are capable of performing I/O operations, such as files and sockets; defines selectors, for multiplexed, non-blocking I/O operations. |
| java.nio.channels.spi | Service-provider classes for the *java.nio.channels* package. |
| java.nio.charset | Defines charsets, decoders, and encoders, for translating between bytes and Unicode characters. |
| java.nio.charset.spi | Service-provider classes for the *java.nio.charset* package. |
| java.nio.file | Defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems. |
| java.nio.file.attribute | Interfaces and classes providing access to file and file system attributes. |
| java.nio.file.spi | Service-provider classes for the *java.nio.file* package. |
| java.rmi | Provides the RMI package. |
| java.rmi.activation | Provides support for RMI Object Activation. |
| java.rmi.dgc | Provides classes and interface for RMI distributed garbage-collection (DGC). |
| java.rmi.registry | Provides a class and two interfaces for the RMI registry. |
| java.rmi.server | Provides classes and interfaces for supporting the server side of RMI. |
| java.security | Provides the classes and interfaces for the security framework. |
| java.security.acl | The classes and interfaces in this package have been superseded by classes in the *java.security* package. |
| java.security.cert | Provides classes and interfaces for parsing and managing certificates, certificate revocation lists (CRLs), and certification paths. |
| java.security.interfaces | Provides interfaces for generating RSA (Rivest, Shamir and Adleman AsymmetricCipher algorithm) keys as defined in the RSA Laboratory Technical Note PKCS#1, and DSA (Digital Signature Algorithm) keys as defined in NIST's FIPS-186. |
| java.security.spec | Provides classes and interfaces for key specifications and algorithm parameter specifications. |
| java.sql | Provides the API for accessing and processing data stored in a data source (usually a relational database) using the Java programming language. |
| **java.text** | Provides classes and interfaces for handling text, dates, numbers, and messages in a manner independent of natural languages. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| java.text.spi | Service provider classes for the classes in the *java.text* package. |
| java.time | The main API for dates, times, instants, and durations. |
| java.time.chrono | Generic API for calendar systems other than the default ISO. |
| java.time.format | Provides classes to print and parse dates and times. |
| java.time.temporal | Access to date and time using fields and units, and date time adjusters. |
| java.time.zone | Support for time-zones and their rules. |
| **java.util** | Contains the collections framework, legacy collection classes, event model, date and time facilities, internationalization, and miscellaneous utility classes (a string tokenizer, a random-number generator, and a bit array). Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |
| java.util.concurrent | Utility classes commonly useful in concurrent programming. |
| java.util.concurrent.atomic | A small toolkit of classes that support lock-free thread-safe programming on single variables. |
| java.util.concurrent.locks | Interfaces and classes providing a framework for locking and waiting for conditions that is distinct from built-in synchronization and monitors. |
| java.util.function | *Functional interfaces* provide target types for lambda expressions and method references. |
| java.util.jar | Provides classes for reading and writing the JAR (Java ARchive) file format, which is based on the standard ZIP file format with an optional manifest file. |
| java.util.logging | Provides the classes and interfaces of the Java 2 platform's core logging facilities. |
| java.util.prefs | This package allows applications to store and retrieve user and system preference and configuration data. |
| java.util.regex | Classes for matching character sequences against patterns specified by regular expressions. |
| java.util.spi | Service provider classes for the classes in the *java.util* package. |
| java.util.stream | Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections. |
| **java.util.zip** | Provides classes for reading and writing the standard ZIP and GZIP file formats. Refer to [Fundamental Classes in Java](#fundamental-classes-in-java) |

<p/>

#### Fundamental Classes in Java

**java.io package**

![java.io package structure](/assets/java.io_package_structure.gif)

![exception classes in java.io package](/assets/exception_classes_in_java.io_package.gif)

**java.lang package**

![java.lang package structure](/assets/java.lang_package_structure.gif)

![exception classes in java.lang package](/assets/exception_classes_in_java.lang_package.gif)

![error classes in java.lang package](/assets/error_classes_in_java.lang_package.gif)

**java.lang.reflect package**

![java.lang.reflect package structure](/assets/java.lang.reflect_package_structure.gif)

**java.math package**

![java.math package structure](/assets/java.math_package_structure.gif)

**java.net package**

![java.net package structure](/assets/java.net_package_structure.png)

**java.text package**

![java.text package structure](/assets/java.text_package_structure.gif)

**java.util package**

![java.util package structure](/assets/java.util_package_structure.gif)

**java.util.zip package**

![java.util.zip package structure](/assets/java.util.zip_package_structure.gif)

### Java Extension Packages

A optional package is an implementation of an open, standard API (examples of optional packages from Sun are [JavaServlet](http://java.sun.com/products/servlet), [Java3D](http://docs.oracle.com/javase/technologies/desktop/java3d/), [JavaManagement](http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/index.jsp)). Most optional packages are rooted in the **javax.\*** namespace, although there may be exceptions. Refer to [The Java Extension Mechanism](http://docs.oracle.com/javase/1.5.0/docs/guide/extensions/index.html) and [Extension Mechanism Architecture](http://docs.oracle.com/javase/1.5.0/docs/guide/extensions/spec.html).

**Java SE 8** has the following extension packages, refer to [Java™ Platform, Standard Edition 8 API Specification](http://docs.oracle.com/javase/8/docs/api/).

| Packages | Description |
| :------- | :---------- |
| javax.accessibility | Defines a contract between user-interface components and an assistive technology that provides access to those components. |
| javax.activation | |
| javax.activity | Contains Activity service related exceptions thrown by the ORB machinery during unmarshalling. |
| javax.annotation | |
| javax.annotation.processing | Facilities for declaring annotation processors and for allowing annotation processors to communicate with an annotation processing tool environment. |
| javax.crypto | Provides the classes and interfaces for cryptographic operations. |
| javax.crypto.interfaces | Provides interfaces for Diffie-Hellman keys as defined in RSA Laboratories' PKCS \#3. |
| javax.crypto.spec | Provides classes and interfaces for key specifications and algorithm parameter specifications. |
| javax.imageio | The main package of the Java Image I/O API. |
| javax.imageio.event | A package of the Java Image I/O API dealing with synchronous notification of events during the reading and writing of images. |
| javax.imageio.metadata | A package of the Java Image I/O API dealing with reading and writing metadata. |
| javax.imageio.plugins.bmp | Package containing the public classes used by the built-in BMP plug-in. |
| javax.imageio.plugins.jpeg | Classes supporting the built-in JPEG plug-in. |
| javax.imageio.spi | A package of the Java Image I/O API containing the plug-in interfaces for readers, writers, transcoders, and streams, and a runtime registry. |
| javax.imageio.stream | A package of the Java Image I/O API dealing with low-level I/O from files and streams. |
| javax.jws | |
| javax.jws.soap | |
| javax.lang.model | Classes and hierarchies of packages used to model the Java programming language. |
| javax.lang.model.element | Interfaces used to model elements of the Java programming language. |
| javax.lang.model.type | Interfaces used to model Java programming language types. |
| javax.lang.model.util | Utilities to assist in the processing of program elements and types. |
| javax.management | Provides the core classes for the Java Management Extensions. |
| javax.management.loading | Provides the classes which implement advanced dynamic loading. |
| javax.management.modelmbean | Provides the definition of the ModelMBean classes. |
| javax.management.monitor | Provides the definition of the monitor classes. |
| javax.management.openmbean | Provides the open data types and Open MBean descriptor classes. |
| javax.management.relation | Provides the definition of the Relation Service. |
| javax.management.remote | Interfaces for remote access to JMX MBean servers. |
| javax.management.remote.rmi | The RMI connector is a connector for the JMX Remote API that uses RMI to transmit client requests to a remote MBean server. |
| javax.management.timer | Provides the definition of the Timer MBean. |
| javax.naming | Provides the classes and interfaces for accessing naming services. |
| javax.naming.directory | Extends the javax.naming package to provide functionality for accessing directory services. |
| javax.naming.event | Provides support for event notification when accessing naming and directory services. |
| javax.naming.ldap | Provides support for LDAPv3 extended operations and controls. |
| javax.naming.spi | Provides the means for dynamically plugging in support for accessing naming and directory services through the javax.naming and related packages. |
| javax.net | Provides classes for networking applications. |
| javax.net.ssl | Provides classes for the secure socket package. |
| javax.print | Provides the principal classes and interfaces for the JavaTM Print Service API. |
| javax.print.attribute | Provides classes and interfaces that describe the types of JavaTM Print Service attributes and how they can be collected into attribute sets. |
| javax.print.attribute.standard | Contains classes for specific printing attributes. |
| javax.print.event | Contains event classes and listener interfaces. |
| javax.rmi | Contains user APIs for RMI-IIOP. |
| javax.rmi.CORBA | Contains portability APIs for RMI-IIOP. |
| javax.rmi.ssl | Provides implementations of RMIClientSocketFactory and RMIServerSocketFactory over the Secure Sockets Layer (SSL) or Transport Layer Security (TLS) protocols. |
| javax.script | The scripting API consists of interfaces and classes that define Java Scripting Engines and provides a framework for their use in Java applications. |
| javax.security.auth | Provides a framework for authentication and authorization. |
| javax.security.auth.callback | Provides the classes necessary for services to interact with applications in order to retrieve information (authentication data including usernames or passwords, for example) or to display information (error and warning messages, for example). |
| javax.security.auth.kerberos | Contains utility classes related to the Kerberos network authentication protocol. |
| javax.security.auth.login | Provides a pluggable authentication framework. |
| javax.security.auth.spi | Provides the interface to be used for implementing pluggable authentication modules. |
| javax.security.auth.x500 | Contains the classes that should be used to store X500 Principal and X500 Private Crendentials in a Subject. |
| javax.security.cert | Provides classes for public key certificates. |
| javax.security.sasl | Contains class and interfaces for supporting SASL. |
| javax.sound.midi | Provides interfaces and classes for I/O, sequencing, and synthesis of MIDI (Musical Instrument Digital Interface) data. |
| javax.sound.midi.spi | Supplies interfaces for service providers to implement when offering new MIDI devices, MIDI file readers and writers, or sound bank readers. |
| javax.sound.sampled | Provides interfaces and classes for capture, processing, and playback of sampled audio data. |
| javax.sound.sampled.spi | Supplies abstract classes for service providers to subclass when offering new audio devices, sound file readers and writers, or audio format converters. |
| javax.sql | Provides the API for server side data source access and processing from the JavaTM programming language. |
| javax.sql.rowset | Standard interfaces and base classes for JDBC RowSet implementations. |
| javax.sql.rowset.serial | Provides utility classes to allow serializable mappings between SQL types and data types in the Java programming language. |
| javax.sql.rowset.spi | The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider. |
| javax.swing | Provides a set of "lightweight" (all-Java language) components that, to the maximum degree possible, work the same on all platforms. |
| javax.swing.border | Provides classes and interface for drawing specialized borders around a Swing component. |
| javax.swing.colorchooser | Contains classes and interfaces used by the JColorChooser component. |
| javax.swing.event | Provides for events fired by Swing components. |
| javax.swing.filechooser | Contains classes and interfaces used by the JFileChooser component. |
| javax.swing.plaf | Provides one interface and many abstract classes that Swing uses to provide its pluggable look-andfeel capabilities. |
| javax.swing.plaf.basic | Provides user interface objects built according to the Basic look and feel. |
| javax.swing.plaf.metal | Provides user interface objects built according to the Java look and feel (once codenamed Metal), which is the default look and feel. |
| javax.swing.plaf.multi | Provides user interface objects that combine two or more look and feels. |
| javax.swing.plaf.nimbus | Provides user interface objects built according to the cross-platform Nimbus look and feel. |
| javax.swing.plaf.synth | Synth is a skinnable look and feel in which all painting is delegated. |
| javax.swing.table | Provides classes and interfaces for dealing with *javax.swing.JTable*. |
| javax.swing.text | Provides classes and interfaces that deal with editable and noneditable text components. |
| javax.swing.text.html | Provides the class HTMLEditorKit and supporting classes for creating HTML text editors. |
| javax.swing.text.html.parser | Provides the default HTML parser, along with support classes. |
| javax.swing.text.rtf | Provides a class (RTFEditorKit) for creating Rich-Text-Format text editors. |
| javax.swing.tree | Provides classes and interfaces for dealing with *javax.swing.JTree*. |
| javax.swing.undo | Allows developers to provide support for undo/redo in applications such as text editors. |
| javax.tools | Provides interfaces for tools which can be invoked from a program, for example, compilers. |
| javax.transaction | Contains three exceptions thrown by the ORB machinery during unmarshalling. |
| javax.transaction.xa | Provides the API that defines the contract between the transaction manager and the resource manager, which allows the transaction manager to enlist and delist resource objects (supplied by the resource manager driver) in JTA transactions. |
| javax.xml | |
| javax.xml.bind | Provides a runtime binding framework for client applications including unmarshalling, marshalling, and validation capabilities. |
| javax.xml.bind.annotation | Defines annotations for customizing Java program elements to XML Schema mapping. |
| javax.xml.bind.annotation.adapters | XmlAdapter and its spec-defined sub-classes to allow arbitrary Java classes to be used with JAXB. |
| javax.xml.bind.attachment | This package is implemented by a MIME-based package processor that enables the interpretation and creation of optimized binary data within an MIME-based package format. |
| javax.xml.bind.helpers | JAXB Provider Use Only: Provides partial default implementations for some of the javax.xml.bind interfaces. |
| javax.xml.bind.util | Useful client utility classes. |
| javax.xml.crypto | Common classes for XML cryptography. |
| javax.xml.crypto.dom | DOM-specific classes for the *javax.xml.crypto* package. |
| javax.xml.crypto.dsig | Classes for generating and validating XML digital signatures. |
| javax.xml.crypto.dsig.dom | DOM-specific classes for the *javax.xml.crypto.dsig* package. |
| javax.xml.crypto.dsig.keyinfo | Classes for parsing and processing KeyInfo elements and structures. |
| javax.xml.crypto.dsig.spec | Parameter classes for XML digital signatures. |
| javax.xml.datatype | XML/Java Type Mappings. |
| javax.xml.namespace | XML Namespace processing. |
| javax.xml.parsers | Provides classes allowing the processing of XML documents. |
| javax.xml.soap | Provides the API for creating and building SOAP messages. |
| javax.xml.stream | |
| javax.xml.stream.events | |
| javax.xml.stream.util | |
| javax.xml.transform | This package defines the generic APIs for processing transformation instructions, and performing a transformation from source to result. |
| javax.xml.transform.dom | This package implements DOM-specific transformation APIs. |
| javax.xml.transform.sax | This package implements SAX2-specific transformation APIs. |
| javax.xml.transform.stax | Provides for StAX-specific transformation APIs. |
| javax.xml.transform.stream | This package implements stream- and URIspecific transformation APIs. |
| javax.xml.validation | Provides an API for validation of XML documents. |
| javax.xml.ws | Contains the core JAX-WS APIs. |
| javax.xml.ws.handler | Defines APIs for message handlers. |
| javax.xml.ws.handler.soap | Defines APIs for SOAP message handlers. |
| javax.xml.ws.http | Defines APIs specific to the HTTP binding. |
| javax.xml.ws.soap | Defines APIs specific to the SOAP binding. |
| javax.xml.ws.spi | Defines SPIs for JAX-WS. |
| javax.xml.ws.spi.http | Provides HTTP SPI that is used for portable deployment of JAX-WS web services in containers |
| *javax.xml.ws.wsaddressing* | 	Defines APIs related to WS-Addressing. |
| javax.xml.xpath | Provides an object-model neutral API for the evaluation of XPath expressions and access to the evaluation environment. |

<p/>

### Other Packages

**Java SE 8** also includes the following packages, refer to [Java™ Platform, Standard Edition 8 API Specification](http://docs.oracle.com/javase/8/docs/api/).

| Packages | Description |
| :------- | :---------- |
| org.ietf.jgss | This package presents a framework that allows application developers to make use of security services like authentication, data integrity and data confidentiality from a variety of underlying security mechanisms like Kerberos, using a unified API. |
| org.omg.CORBA | Provides the mapping of the OMG CORBA APIs to the JavaTM programming language, including the class ORB, which is implemented so that a programmer can use it as a fully-functional Object Request Broker (ORB). |
| org.omg.CORBA_2_3 | Defines additions to existing CORBA interfaces in the Java Standard Edition 6. These changes occurred in recent revisions to the CORBA API defined by the OMG. The new methods were added to interfaces derived from the corresponding interfaces in the CORBA package.  This provides backward compatibility and avoids breaking the JCK tests. |
| org.omg.CORBA_2_3.portable | Provides methods for the input and output of value types, and contains other updates to the *org/omg/CORBA/portable* package. |
| org.omg.CORBA.DynAnyPackage | Provides the exceptions used with the DynAny interface (InvalidValue, Invalid, InvalidSeq, and TypeMismatch). |
| org.omg.CORBA.ORBPackage | Provides the exception InvalidName, which is thrown by the method ORB.resolve_initial_references and the exception InconsistentTypeCode, which is thrown by the Dynamic Any creation methods in the ORB class. |
| org.omg.CORBA.portable | Provides a portability layer, that is, a set of ORB APIs that makes it possible for code generated by one vendor to run on another vendor's ORB. |
| org.omg.CORBA.TypeCodePackage | Provides the user-defined exceptions BadKind and Bounds, which are thrown by methods in in the class TypeCode. |
| org.omg.CosNaming | Provides a naming service for Java IDL. |
| org.omg.CosNaming.NamingContextExtPackage | Contains the following classes, which are used in *org.omg.CosNaming.NamingContextExt* |
| org.omg.CosNaming.NamingContextPackage | Contains Exception classes for the *org.omg.CosNaming* package. |
| org.omg.Dynamic | Contains the Dynamic module specified in the [OMG Portable Interceptor specification, section 21.9](http://cgi.omg.org/cgi-bin/doc?ptc/2000-08-06). |
| org.omg.DynamicAny | Provides classes and interfaces that enable traversal of the data value associated with an any at runtime, and extraction of the primitive constituents of the data value. |
| org.omg.DynamicAny.DynAnyFactoryPackage | Contains classes and exceptions from the DynAnyFactory interface of the DynamicAny module specified in the OMG The Common Object Request Broker: [Architecture and Specification, section 9.2.2](http://cgi.omg.org/cgi-bin/doc?formal/99-10-07). |
| org.omg.DynamicAny.DynAnyPackage | Contains classes and exceptions from the DynAny interface of the DynamicAny module specified in the OMG The Common Object Request Broker: [Architecture and Specification, section 9.2](http://cgi.omg.org/cgi-bin/doc?formal/99-10-07). |
| org.omg.IOP | Contains the IOP module specified in the OMG document The Common Object Request Broker: [Architecture and Specification, section 13.6](http://cgi.omg.org/cgi-bin/doc?formal/99-10-07). |
| org.omg.IOP.CodecFactoryPackage | Contains the exceptions specified in the IOP::CodeFactory interface (as part of the Portable Interceptors spec). |
| org.omg.IOP.CodecPackage | This package is generated from the IOP::Codec IDL interface definition. |
| org.omg.Messaging | Contains the Messaging module specified in the [OMG CORBA Messaging specification](http://cgi.omg.org/cgi-bin/doc?formal/99-10-07). |
| org.omg.PortableInterceptor | Provides a mechanism to register ORB hooks through which ORB services can intercept the normal flow of execution of the ORB. |
| org.omg.PortableInterceptor.ORBInitInfoPackage | Contains the exceptions and typedefs from the ORBInitInfo local interface of the PortableInterceptor module specified in the [OMG Portable Interceptor specification, section 21.7.2](http://cgi.omg.org/cgi-bin/doc?ptc/2000-08-06). |
| org.omg.PortableServer | Provides classes and interfaces for making the server side of your applications portable across multivendor ORBs. |
| org.omg.PortableServer.CurrentPackage | Provides method implementations with access to the identity of the object on which the method was invoked. |
| org.omg.PortableServer.POAManagerPackage | Encapsulates the processing state of the POAs it is associated with. |
| org.omg.PortableServer.POAPackage | Allows programmers to construct object implementations that are portable between different ORB products. |
| org.omg.PortableServer.portable | Provides classes and interfaces for making the server side of your applications portable across multivendor ORBs. |
| org.omg.PortableServer.ServantLocatorPackage | Provides classes and interfaces for locating the servant. |
| org.omg.SendingContext | Provides support for the marshalling of value types. |
| org.omg.stub.java.rmi | Contains RMI-IIOP Stubs for the Remote types that occur in the *java.rmi* package. |
| org.w3c.dom | Provides the interfaces for the Document Object Model (DOM). |
| org.w3c.dom.bootstrap | |
| org.w3c.dom.events | |
| org.w3c.dom.ls | |
| org.w3c.dom.views | |
| org.xml.sax | Provides the core SAX APIs. |
| org.xml.sax.ext | Contains interfaces to SAX2 facilities that conformant SAX drivers won't necessarily support. |
| org.xml.sax.helpers | Contains *helper* classes, including support for bootstrapping SAX-based applications. |

<p/>

### Java Permission Classes

Java has the following permission classes in [Java Bootstrap Packages](#java-bootstrap-packages) and [Java Extension Packages](#java-extension-packages):

| Permission Classes | Description |
| :----------------- | :---------- |
| java.security.AllPermission | An instance of this special permission class implies all other permissions. |
| javax.sound.sampled.AudioPermission | Controls the ability to play and record sound. |
| javax.security.auth.AuthPermission | Controls access to authentication methods in *javax.security.auth* and its subpackages. |
| java.awt.AWTPermission | Controls access to sensitive methods in *java.awt* and its subpackages. |
| java.io.FilePermission | Governs access to the filesystem. |
| java.util.logging.LoggingPermission | Controls the ability of a program to modify the logging configuration. |
| java.net.NetPermission | Governs access to networking-related resources such as stream handlers and HTTP authentication. See also *java.net.SocketPermission*. |
| java.util.PropertyPermission | Governs access to system properties. |
| java.lang.reflect.ReflectPermission | Governs access through the *java.lang.reflect* package to classes and class members that would normally be inaccessible. |
| java.lang.RuntimePermission | Governs access to a number of methods and resources. Many of the controlled methods are defined by *java.lang.System* and *java.lang.Runtime*. |
| java.security.SecurityPermission | Governs access to various security-related methods. |
| java.io.SerializablePermission | Governs access to serialization-related methods. |
| java.net.SocketPermission | Governs access to the network. |
| java.sql.SQLPermission | Governs the ability to specify logging streams in the *java.sql* JDBC API |.

<p/>

## JDK Tools and Utilities

Sun's implementation of Java includes a number of tools for Java developers, refer to [JDK Tools and Utilities of Java Plantform SE 8](http://docs.oracle.com/javase/8/docs/technotes/tools/index.html):

| Tools | Description |
| :---- | :---------- |
| apt   | Annotation Processing Tool. |
| extcheck | JAR Version Conflict Utility. *extcheck* checks to see if the extension contained in the specified *jarfile* (or a newer version of that extension) has already been installed on the system. |
| jarsigner | JAR Signing and Verification Tool. *jarsigner* adds a digital signature to the specified *jarfile*, or, if the ```-verify``` option is specified, it verifies the digital signature or signatures already attached to the JAR file. *jarsigner* and the related *keytool* program replace the *javakey* program of Java 1.1. |
| **jar** | Java Archive Tool. *jar* is a tool that can create and manipulate Java Archive (JAR) files. A JAR file is a ZIP file that contains Java class files, auxiliary resource files required by those classes, and optional meta-information. |
| **java** | The Java Interpreter. *java* is the Java byte-code interpreter; it runs Java programs. The program to be run is the class specified by *classname*. This must be a fully qualified name: it must include the package name of the class but not the *.class* file extension. The specified class must define a *main()* method with exactly the following signature: ```public static void main(String[] args)```. In Java 1.2 and later, a program can be packaged in an executable JAR file. To run a program packaged in this fashion, use the ```-jar``` option to specify the JAR file. The Java interpreter runs until the *main()* method exits, and any threads (except for threads marked as daemon threads) created by the program have also exited. |
| **javac** | The Java Compiler. *javac* is the Java compiler; it compiles Java source code (in *.java* files) into Java byte codes (in *.class* files). The Java compiler is itself written in Java. |
| **javadoc** | The Java Documentation Generator. *javadoc* generates API documentation for any number of packages and classes you specify. *javadoc* uses the *javac* compiler to process all the specified Java source files and all the Java source files in all the specified packages. It uses the information it gleans from this processing to generate detailed API documentation. *javadoc* creates HTML documentation by default, but you can customize its behavior by defining a doclet class that generates documentation in whatever format you desire. |
| javah | Native Method C Stub Generator. *javah* generates C header and source files (*.h* and *.c* files) that are used when implementing Java native methods in C. |
| javap | The Java Class Disassembler. *javap* reads the class files specified by the class names on the command line and prints a human-readable version of the API defined by those classes. *javap* can also disassemble the specified classes, displaying the Java VM byte codes for the methods they contain. |
| javaws | Java Web Start launcher. *javaws* is the command-line interface to the Java Web Start network application launcher. When started without a *url*, *javaws* displays a graphical cache viewer which allows cached applications to be launched and Java Web Start to be configured. |
| jconsole | Graphical Java Process Monitor. *jconsole* is a graphical interface to the memory, thread, class loading, and other monitoring tools provided by the java.lang.management package. It can monitor one or more local or remote Java processes. |
| **jdb** | The Java Debugger. *jdb* is a debugger for Java classes. It is text-based, command-line-oriented, and has a command syntax like that of the Unix *dbx* or *gdb* debuggers used with C and C++ programs. *jdb* can also debug a program that is already running in another Java interpreter.  |
| jinfo | Display configuration of a Java process. *jinfo* prints the system properties and JVM command-line options for a running Java process or core file. In Java 5.0, *jinfo* is experimental, unsupported, and not available on all platforms. |
| jmap | Display memory usage. *jmap* prints memory usage information for a local or remote Java process or a Java core file. Depending on the option it is invoked with, jmap displays one of four memory usage reports. In Java 5.0, *jmap* is experimental, unsupported, and not available on all platforms. |
| **jps** | List Java processes. *jps* lists the Java processes running on the local host or on the specified remote host. If a remote host is specified, it must be running the *jstatd* daemon. For each Java process, it displays a process id and names the class or JAR file that the process is executing. Process ids are used by a number of other Java tools, such as *jconsole*, *jstat*, and *jmap*. For instance, ```jps -lmv``` |
| jsadebugd | Daemon process for remote debugging. *jsadebugd* is a server process that allows remote invocations of *jinfo*, *jmap*, and *jstack* on a local Java process or core file. In Java 5.0, *jsadebugd* is experimental, unsupported, and not available on all platforms. |
| jstack | Display stack traces for a Java process. *jstack* prints stack traces for each of the Java threads running in the specified Java process. |
| **jstat** | Java VM statistics. *jstat* probes a running JVM once or repeatedly and displays statistics about its class loading, just-in-time compilation, memory, or garbage collection performance. *jconsole* can report many of the same statistics that *jstat* does but displays them in graphical rather than tabular form. |
| jstatd | *jstat* daemon. *jstatd* is a server that provides information about local Java processes to the *jps* and *jstat* programs running on remote hosts. |
| keytool | Key and Certificate Management Tool. keytool manages and manipulates a *keystore*, a repository for public and private keys and public key certificates. *keytool* defines various commands for generating keys, importing data into the keystore, and exporting and displaying keystore data. Keys and certificates are stored in a keystore using a case-insensitive name or *alias*. *keytool* uses this alias to refer to a key or certificate. |
| native2ascii | Convert text to ASCII with Unicode escapes. *native2ascii* is a simple program that reads a text file (usually of Java source code) encoded using a local encoding and converts it to a Latin-1-plus-ASCII-encodedUnicode form allowed by the Java Language Specification. This is helpful when you must edit a file of Java code but do not have an editor that can handle the encoding of the file. |
| pack200 | Compress a JAR file. *pack200* tightly compresses a JAR file using the compression algorithm defined by JSR 200 and the standard gzip compression algorithm. Notice that the output file is specified on the command line before the input JAR file. |
| policytool | Policy File Creation and Management Tool. *policytool* displays a Swing user interface that makes it easy to edit security policy configuration files. |
| serialver | Class Version Number Generator. *serialver* displays the version number of a class or classes. This version number is used for the purposes of serialization: the version number must change each time the serialization format of the class changes. |
| unpack200 | Unpack a JAR file. *unpack200* unpacks a JAR file that has been compressed, or *packed*, by the *pack200* tool, and optionally additionally compressed with gzip. |

<p/>

# Implementations of Java Platform SE

## OpenJDK

[OpenJDK](http://openjdk.java.net) is a free and open source implementation of the **Java Platform, Standard Edition (Java SE)**.

Before OpenJDK, several free Java implementations were made by various companies and groups. One example is Apache Harmony. IBM also provides Java implementations, and RedHat provides it through the IcedTea project: a build and integration project for OpenJDK.

# Java Compiling and Execution

In the Java programming language, all source code is first written in plain text files ending with the *.java* extension. Those source files are then compiled into *.class* files by the ```javac``` compiler. A *.class* file does not contain code that is native to your processor; it instead contains bytecodes — the machine language of the [Java Virtual Machine (Java VM)](#java-virtual-machine-jvm). The ```java``` launcher tool then runs your application with an instance of the Java Virtual Machine.

![An overview of the software development process](/assets/Java_Compiler.gif)

Because the Java VM is available on many different operating systems, the same *.class* files are capable of running on Microsoft Windows, the Solaris™ Operating System (Solaris OS), Linux, or Mac OS. Some virtual machines, such as the [Java SE HotSpot at a Glance](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html), perform additional steps at runtime to give your application a performance boost. This includes various tasks such as finding performance bottlenecks and recompiling (to native code) frequently used sections of code. Refer to [About the Java Technology](http://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html).

![Through the Java VM, the same application is capable of running on multiple platforms](/assets/Java_application_running_on_multiple_platforms.gif)

# Java Language

## Keywords

Here is a list of keywords in the Java programming language. You cannot use any of the following as identifiers in your programs. The keywords ```const``` and ```goto``` are reserved, even though they are not currently used. ```true```, ```false```, and ```null``` might seem like keywords, but they are actually literals; you cannot use them as identifiers in your programs.

| ```abstract```   | ```continue``` | ```for```        | ```new```          | ```switch```       |
| ```assert``` [3] | ```default```  | ```goto``` [1]   | ```package```      | ```synchronized``` |
| ```boolean```    | ```do```       | ```if```         | ```private```      | ```this```         |
| ```break```      | ```double```   | ```implements``` | ```protected```    | ```throw```        |
| ```byte```       | ```else```     | ```import```     | ```public```       | ```throws```       |
| ```case```       | ```enum``` [4] | ```instanceof``` | ```return```       | ```transient```    |
| ```catch```      | ```extends```  | ```int```        | ```short```        | ```try```          |
| ```char```       | ```final```    | ```interface```  | ```static```       | ```void```         |
| ```class```      | ```finally```  | ```long```       | ```strictfp``` [2] | ```volatile```     |
| ```const``` [1]  | ```float```    | ```native```     | ```super```        | ```while```        |

<p/>

* [1] not used
* [2] added in 1.2
* [3] added in 1.4
* [4] added in 5.0

## Operators

As we explore the operators of the Java programming language, it may be helpful for you to know ahead of time which operators have the highest precedence. The operators in the following table are listed according to precedence order. The closer to the top of the table an operator appears, the higher its precedence. Operators with higher precedence are evaluated before operators with relatively lower precedence. Operators on the same line have equal precedence. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first. All binary operators except for the assignment operators are evaluated from left to right; assignment operators are evaluated right to left. Refer to [Operators](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html) and [Summary of Operators](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html).

**Operator Precedence**

| Operators            | Precedence |
| :------------------- | :--------- |
| postfix              | ```expr++``` ```expr--``` |
| unary                | ```++expr``` ```--expr``` ```+expr``` ```-expr``` ```~``` ```!``` |
| multiplicative       | ```*``` ```/``` ```%``` |
| additive             | ```+``` ```-``` |
| shift                | ```<<``` ```>>``` ```>>>``` |
| relational           | ```<``` ```>``` ```<=``` ```>=``` ```instanceof``` |
| equality             | ```==``` ```!=``` |
| bitwise AND          | ```&``` |
| bitwise exclusive OR | ```^``` |
| bitwise inclusive OR | ```|``` |
| logical AND          | ```&&``` |
| logical OR           | ```||``` |
| ternary              | ```? :``` |
| assignment           | ```=``` ```+=``` ```-=``` ```*=``` ```/=``` ```%=``` ```&=``` ```^=``` ```|=``` ```<<=``` ```>>=``` ```>>>=``` |

<p/>

![Java Operators](/assets/Java_operators.png)

**Simple Assignment Operator**

| ```=``` | Simple assignment operator |

<p/>

**Arithmetic Operators**

| ```+```  | Additive operator (also used for String concatenation) |
| ```-```  | Subtraction operator    |
| ```*```  | Multiplication operator |
| ```/```  | Division operator       |
| ```%```  | Remainder operator      |

<p/>

**Unary Operators**

| ```+```  | Unary plus operator; indicates positive value (numbers are positive without this, however) |
| ```-```  | Unary minus operator; negates an expression |
| ```++``` | Increment operator; increments a value by 1 |
| ```--``` | Decrement operator; decrements a value by 1 |
| ```!```  | Logical complement operator; inverts the value of a boolean |

<p/>

**Equality and Relational Operators**

| ```==``` | Equal to         |
| ```!=``` | Not equal to     |
| ```>```  | Greater than     |
| ```<```  | Less than        |
| ```>=``` | Greater than or equal to |
| ```<=``` | Less than or equal to    |

<p/>

**Conditional Operators**

| ```&&``` | Conditional-AND |
| ```||``` | Conditional-OR  |
| ```?:``` | Ternary (shorthand for ```if-then-else``` statement) |

<p/>

**Type Comparison Operator**

| ```instanceof``` | Compares an object to a specified type |

<p/>

* The ```instanceof``` operator requires an object or array value as its left operand and the name of a reference type as its right operand. It evaluates to ```true``` if the object or array is an instance of the specified type; it returns ```false``` otherwise.
* If the left operand is ```null```, ```instanceof``` always evaluates to ```false```.
* If an ```instanceof``` expression evaluates to ```true```, it means that you can safely cast and assign the left operand to a variable of the type of the right operand.
* The ```instanceof``` operator can be used only with reference types and objects, not primitive types and values.

**Bitwise and Bit Shift Operators**

| ```~```   | Unary bitwise complement |
| ```<<```  | shift left               |
| ```>>```  | shift right              |
| ```>>>``` | Unsigned shift right     |
| ```&```   | Bitwise AND              |
| ```^```   | Bitwise exclusive OR     |
| ```|```   | Bitwise inclusive OR     |

<p/>

* The ```<<``` operator shifts the bits of the left operand left by the number of places specified by the right operand. **High-order bits of the left operand are lost, and zero bits are shifted in from the right**.
* The ```>>``` operator shifts the bits of the left operand to the right by the number of places specified by the right operand. **The low-order bits of the left operand are shifted away and are lost. The high-order bits shifted in are the same as the original high-order bit of the left operand**.
* This ```>>>``` operator is like the ```>>``` operator, except that **it always shifts zeros into the high-order bits of the result**, regardless of the sign of the left-hand operand. This technique is called *zero extension*; it is appropriate when the left operand is being treated as an unsigned value (despite the fact that Java integer types are all signed).

## Comments

Java has the following three kinds of comments:

```
// comments until the end of the line

/*
 * multiline comment
 */

/**
 * documentation comment (doc comment, for short)
 *
 * the javadoc tool uses doc comments when preparing
 * automatically generated documentation.
 */
```

### Doc Comments

Refer to [Javadoc tool documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html):

* A *doc comment* appears immediately before a type or member definition and contains documentation for that type or member.
* The descriptive material in a *doc comment* can contain simple HTML markup tags.

```
/**
* This immutable class represents <i>complex numbers</i>.
*
* @author David Flanagan
* @version 1.0
*/
public class Complex {
    /**
     * Holds the real part of this complex number.
     * @see #y
     */
    protected double x;
    /**
     * Holds the imaginary part of this complex number.
     * @see #x
     */
    protected double y;
    /**
     * Creates a new Complex object that represents the complex number x+yi.
     * @param x The real part of the complex number.
     * @param y The imaginary part of the complex number.
     */
    public Complex(double x, double y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Adds two Complex objects and produces a third object that represents
     * their sum.
     * @param c1 A Complex object
     * @param c2 Another Complex object
     * @return A new Complex object that represents the sum of
     *         <code>c1</code> and <code>c2</code>.
     * @exception java.lang.NullPointerException
     *            If either argument is <code>null</code>.
     */
    public static Complex add(Complex c1, Complex c2) {
        return new Complex(c1.x + c2.x, c1.y + c2.y);
    }
}
```

#### Doc-Comment Tags

*javadoc* recognizes a number of special tags, each of which begins with an ```@``` character.

The following *doc comment* tags are recognized by *javadoc*; a *doc comment* should typically use these tags in the order listed here:

* **@author** *name*

    Adds an **Author:** entry that contains the specified name. This tag should be used for every class or interface definition but must not be used for individual methods and fields.

* **@version** *text*

    Inserts a **Version:** entry that contains the specified text. This tag should be included in every class and interface *doc comment* but cannot be used for individual methods and fields.

* **@param** *parameter-name* *description*

    Adds the specified parameter and its description to the **Parameters:** section of the current method. The *doc comment* for a method or constructor must contain one @param tag for each parameter the method expects. These tags should appear in the same order as the parameters specified by the method. The tag can be used only in *doc comments* for methods and constructors.

* **@return** *description*

    Inserts a **Returns:** section that contains the specified description. This tag should appear in every *doc comment* for a method, unless the method returns ```void``` or is a constructor.

* **@exception** *full-classname* *description* / **@throws** *full-classname* *description*

    Adds a **Throws:** entry that contains the specified exception name and description. A *doc comment* for a method or constructor should contain an @exception tag for every checked exception that appears in its *throws* clause.

    If a method can throw more than one exception, use multiple @exception tags on adjacent lines and list the exceptions in alphabetical order.

    This tag can be used only for method and constructor comments. The @throws tag is a synonym for @exception.

* **@see** *reference*

    Adds a **See Also:** entry that contains the specified reference. This tag can appear in any kind of *doc comment*.

* **@deprecated** *explanation*

    This tag specifies that the following type or member has been deprecated and that its use should be avoided. *javadoc* adds a prominent **Deprecated** entry to the documentation and includes the specified *explanation* text.

* **@since** *version*

    Specifies when the type or member was added to the API. This tag should be followed by a version number or other version specification.

    Every *doc comment* for a type should include an @since tag, and any members added after the initial release of the type should have @since tags in their *doc comments*.

* **@serial** *description*

    If you write a class that you expect to be serialized, you should document its serialization format using @serial and the related tags listed below. @serial should appear in the *doc comment* for any field that is part of the serialized state of a Serializable class.

* **@serialField** *name* *type* *description*

    A Serializable class can define its serialized format by declaring an array of *ObjectStreamField* objects in a field named *serialPersistentFields*. For such a class, the *doc comment* for *serialPersistentFields* should include an @serialField tag for each element of the array.

* **@serialData** *description*

    A *Serializable* class can define a *writeObject()* method to write data other than that written by the default serialization mechanism. An *Externalizable* class defines a *writeExternal()* method responsible for writing the complete state of an object to the serialization stream. The @serialData tag should be used in the *doc comments* for these *writeObject()* and *writeExternal()* methods, and the description should document the serialization format used by the method.

#### Inline Doc-Comment Tags

In addition to the preceding tags, *javadoc* also supports several inline tags that may appear anywhere that HTML text appears in a *doc comment*.

* {@link *reference*} // Java 1.2 and later
* {@linkplain *reference*} // Java 1.4 and later
* {@inheritDoc}
* {@docRoot} // Java 1.3 and later
* {@literal *text*} // Java 5.0 and later
* {@code *text*} // Java 5.0 and later
* {@value} // Java 1.4 and later
* {@value *reference*} // Java 5.0 and later

#### Doc-Comments for Packages

*javadoc* can also read and display summary documentation for packages. Since a package is defined in a directory, not in a single file of source code, *javadoc* looks for the package documentation in a file named *package.html* in the directory that contains the source code for the classes of the package.

The *package.html* file should contain simple HTML documentation for the package. It can also contain @see, @link, @deprecated, and @since tags. Since *package.html* is not a file of Java source code, the documentation it contains should be HTML and should not be a Java comment (i.e., it should not be enclosed within ```/**``` and ```*/``` characters). Finally, any @see and @link tags that appear in *package.html* must use fully qualified class names.

In addition to defining a *package.html* file for each package, you can also provide high-level documentation for a group of packages by defining an *overview.html* file in the source tree for those packages. When *javadoc* is run over that source tree, it uses *overview.html* as the highest level overview it displays.

## Primitive Data Types

Java has the following primitive data types:

| Type    | Bits | Contains | Default | Range |
| :------ | :--- | :------- | :------ | :---- |
| boolean | 1    | true or false | false | NA |
| char    | 16   | Unicode Character Set | \u0000  | \u0000 .. \uFFFF |
| byte    | 8    | Signed integer | 0 | -128 .. 127 |
| short   | 16   | Signed integer | 0 | -32,768 .. 32,767 |
| int     | 32   | Signed integer | 0 | -2,147,483,648 .. 2,147,483,647 |
| long    | 64   | Signed integer | 0 | -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807 |
| float   | 32   | IEEE 754 floating point | 0.0 | ±1.4E-45 .. ±3.4028235E+38 |
| double  | 64   | IEEE 754 floating point | 0.0 | ±4.9E-324 .. ±1.7976931348623157E+308 |

<p/>

Declare a variable:

```
{public | private} [static] type identifier [= expression];
```

**boolean**

* C and C++ programmers should note that Java is quite strict about its *boolean* type: *boolean* values can never be converted to or from other data types.
* *boolean* is not an integral type, and integer values cannot be used in place of a *boolean*.

**char**

* *char* values can be converted to and from the various integral types.
* Unlike *byte*, *short*, *int*, and *long*, however, *char* is an unsigned type.
* *char* acts like an integer type in most ways, so a *char* value can be used anywhere an *int* or *long* value is required.
* Unicode standard is evolving, and each new version of Java adopts the latest version of Unicode. Java 1.4 used Unicode 3.0 and Java 5.0 adopts Unicode 4.0.

**Integer types: byte, short, int, long**

* All integral types represent signed numbers; there is no unsigned keyword as there is in C and C++.
* Integer literals can also be expressed in hexadecimal (0x123) or octal notation (0123). Java does not allow integer literals to be expressed in binary (base-2) notation.
* Integer literals are 32-bit *int* values unless they end with the character ```L``` or ```l```, in which case they are 64-bit *long* values.
* Each integer type has a corresponding wrapper class: *Byte*, *Short*, *Integer*, and *Long*. Each of these classes defines **MIN_VALUE** and **MAX_VALUE** constants that describe the range of the type.

**Floating-Point types: float, double**

* Real numbers in Java are represented by the *float* and *double* data types.
* Floating-point literals are *double* values by default. To include a *float* value literally in a program, follow the number with ```F``` or ```f```.
* Floating-point literals cannot be expressed in hexadecimal or octal notation.
* In addition to representing ordinary numbers, the *float* and *double* types can also represent four special values: positive and negative infinity, zero, and NaN. The infinity values result when a floating-point computation produces a value that overflows the representable range of a float or double. When a floating-point computation underflows the representable range of a float or a double, a zero value results. NaN stands for *not-a-number*. The NaN value results when an illegal floating-point operation, such as 0.0/0.0, is performed.
* Because the Java floating-point types can handle overflow to infinity and underflow to zero and have a special NaN value, **floating-point arithmetic never throws exceptions**, even when performing illegal operations, like dividing zero by zero or taking the square root of a negative number.
* The *float* and *double* primitive types have corresponding classes, named *Float* and *Double*. Each of these classes defines the following useful constants: MIN_VALUE, MAX_VALUE, NEGATIVE_INFINITY, POSITIVE_INFINITY, and NaN.

#### Primitive Type Conversions

There are two basic types of conversions:

* *Widening conversion* occurs when a value of one type is converted to a wider type — one that has a larger range of legal values. Java performs widening conversions automatically when, for example, you assign an int literal to a double variable or a char literal to an int variable.
* *Narrowing conversions* are another matter, however. A narrowing conversion occurs when a value is converted to a type that is not wider than it is.

The following table shows which primitive types can be converted to which other types and how the conversion is performed.

![Java Primitive Type Conversions](/assets/Java_primitive_type_conversions.png)

* The letter **N** in the table means that the conversion cannot be performed.
* The letter **Y** means that the conversion is a *widening conversion* and is therefore performed automatically and implicitly by Java.
* The letter **C** means that the conversion is a *narrowing conversion* and requires an explicit cast.
* The notation **Y\*** means that the conversion is an automatic *widening conversion*, but that some of the least significant digits of the value may be lost in the conversion.

## Wrappers of Primitive Data Types

The *java.lang* package includes the corresponding Byte, Short, Integer, Long, Float, and Double classes, each of which is a subclass of Number.

| Primitive Types | Wrappers of Primitive Types |
| :-------------- | :-------------------------- |
| boolean         | java.lang.Boolean           |
| char            | java.lang.Character         |
| byte            | java.lang.Byte              |
| short           | java.lang.Short             |
| int             | java.lang.Integer           |
| long            | java.lang.Long              |
| float           | java.lang.Float             |
| double          | java.lang.Double            |

<p/>

## Arrays

Declare an integer array and allocate 100 elements of memory:

```
int array_name[];
array_name=new int[100];
```

Declare and allocate an integer array in one statement:

```
int array_name[] = new int [100];
int array_name[] = {1, 2, 3, 4};
```

Multidimensional array:

```
int array_name[] = new int[10][20];
```

For reference type (class, array):

```
null
```

## Flow Control Statements

**if..else**

```
if (Boolean-expression)
    statement1;
[ else statement2; ]
```

**while**

```
[initialization]
while (termination-clause) {
    body;
    [iteration;]
}
```

**do while**

```
do {
    body;
    [iteration;]
} while (termination-clause);
```

**for**

```
for (initialization; termination-clause; iteration)
{
    body;
}
```

**for/in**

```
for (declaration : expression)
{
	statement;
}
```

* *expression* must be either an array or an object that implements the *java.lang.Iterable* interface.
* The type of the array or Iterable elements must be assignment-compatible with the type of the variable declared in the *declaration*.

**Program Structure**

```
{public | final | abstract} class className {
    public static void main (String args[ ]) {
        statements;
    }

    method definition1
    ...
    method definitionN
}
```

## Threads and Concurrency

Java makes it easy to define and work with multiple threads of execution within a program. *java.lang.Thread* is the fundamental thread class in the Java API. There are two ways to define a thread:

* One is to subclass *Thread*, override the *run()* method and then instantiate your Thread subclass.
* The other is to define a class that implements the *Runnable* method (i.e., define a *run()* method) and then pass an instance of this Runnable object to the *Thread()* constructor.

In either case, the result is a *Thread* object, where the *run()* method is the body of the thread. When you call the *start()* method of the *Thread* object, the interpreter creates a new thread to execute the *run()* method. This new thread continues to run until the *run()* method exits. Meanwhile, the original thread continues running itself, starting with the statement following the *start()* method.

A thread can be in one of six states. In Java 5.0, these states are represented by the *Thread.State* enumerated type, and the state of a thread can be queried with the *getState()* method. A listing of the *Thread.State* constants provides a good overview of the lifecycle of a thread:

| States | Description |
| :----- | :---------- |
| NEW    | The Thread has been created but its *start()* method has not yet been called. All threads start in this state. |
| RUNNABLE | The thread is running or is available to run when the operating system schedules it. |
| BLOCKED | The thread is not running because it is waiting to acquire a lock so that it can enter a *synchronized* method or block. |
| WAITING | The thread is not running because it has called *Object.wait()* or *Thread.join()*. |
| TIMED_WAITING | The thread is not running because it has called *Thread.sleep()* or has called *Object.wait()* or *Thread.join()* with a timeout value. |
| TERMINATED | The thread has completed execution. Its *run()* method has exited normally or by throwing an exception. |

<p/>

# Comparison of Java and C++

Refer to [Comparison of Java and C++](https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B).

# Java Code Conventions

Refer to the following code conventions from Alibaba and Google:

* [阿里巴巴Java开发手册v1.0.1](/docs/Alibaba_Java_Development_v1.0.1.pdf)
* [Google Java Style](http://www.hawstein.com/posts/google-java-style.html)

None of the conventions described here are mandatory. Following them, however, will make your code easier to read and maintain, portable, and self-documenting.

**Packages**

* Ensure that your publicly visible package names are unique by prefixing them with the inverted name of your Internet domain (e.g., com.davidflanagan.utils).
* All package names should be lowercase.

**Reference types**

* A type name should begin with a capital letter and be written in mixed case (e.g., String).
* If a class name consists of more than one word, each word should begin with a capital letter (e.g., StringBuffer).
* If a type name, or one of the words of a type name, is an acronym, the acronym can be written in all capital letters (e.g., URL, HTMLParser).
* Since classes and enumerated types are designed to represent objects, you should choose class names that are nouns.
* When an interface is used to provide additional information about the classes that implement it, it is common to choose an interface name that is an adjective (e.g., Runnable, Cloneable, Serializable). When an interface works more like an abstract superclass, use a name that is a noun (e.g., Document, FileNameMap, Collection).

**Methods**

* A method name always begins with a lowercase letter.
* If the name contains more than one word, every word after the first begins with a capital letter (e.g., insert( ), insertObject(), insertObjectAt( )).
* Method names are typically chosen so that the first word is a verb.

**Fields and constants**

* Nonconstant field names follow the same capitalization conventions as method names.
* If a field is a ```static final``` constant, it should be written in uppercase. If the name of a constant includes more than one word, the words should be separated with underscores (e.g., MAX_VALUE).
* The constants defined by ```enum``` types are also typically written in all capital letters.

**Parameters**

* Method parameters follow the same capitalization conventions as nonconstant fields.

**Local variables**

* Variables are typically named following the same conventions as methods and fields.

# Books

* Thinking in Java, 3rd edition (Bruce Eckel; Prentice Hall PTR, 2002)

  Java 编程思想：第3版 (陈昊鹏 等译, 机械工业出版社, 2005年)

* Effective Java: Programming Language Guide (Joshua Bloch; Addison-Wesley, 2001年)

  Effective Java 中文版 (潘爱民 译, 机械工业出版社, 2003年)

* The Java Programming Language (Ken Arnold，James Gosling，David Holmes; Addison-Wesley, 2000年)

  Java 编程语言(第3版) (虞万荣 等译, 中国电力出版社, 2003年)

* Concurrent Programming in Java: Design Principles and Patterns, 2nd edition (Doug Lea; Addison-Wesley, 1999年)

  Java 并发编程—设计原则与模式(第二版) (赵涌 等译, 中国电力出版社, 2004年)

* Expert One-On-One J2EE Design and Development (Rod Johnson)

  WROX: J2EE 设计开发编程指南 (魏海萍 译, 电子工业出版社, 2003年)

* Refactoring: Improving the Design of Existing Code (Martin Fowler, Kent Beck, John Brant, William Opdyke, Don Roberts; Addison-Wesley, 1999年)

  重构：改善既有代码的设计(中文版) (侯捷 等译, 中国电力出版社, 2003年)

* Design Patterns: Elements of Reusable Object Oriented Software (Erich Gamma, Richard Helm，Ralph Johnson, John Vlissides; Addison-Wesley, 1997年)

  设计模式：可复用面向对象软件的基础 (李英军 等译, 机械工业出版社, 2005年)

* Patterns of Enterprise Application Architecture (Martin Fowler; Addison-Wesley, 2002年)

  企业应用架构模式 (王怀民 等译, 机械工业出版社, 2004年)

* UML Distilled: A Brief Guide to the Standard Object Modeling Language (Martin Fowler; Addison-Wesley, 2003年)

  UML精粹：标准对象语言简明指南(第3版) (徐家福 译, 清华大学出版社, 2005年)

* Test-Driven Development: By Example (Kent Beck; Addison-Wesley, 2002年)

  测试驱动开发(中文版) (崔凯 译, 中国电力出版社, 2004年)

* The Pragmatic Programmer: From Journeyman to Master (Andrew Hunt, David Thomas; Addison-Wesley, 1999年)

  程序员修炼之道——从小工到专家 (马维达 译, 电子工业出版社, 2004年)

* Peopleware: Productive Projects and Teams (Tom DeMarco, Timothy Lister; Dorset House, 1999年)

  人件(第2版) (UMLChina 翻译组 译, 清华大学出版社, 2003年)

# References

* [Java Official Site](https://www.oracle.com/java/index.html)
* [Java Overview](http://www.oracle.com/technetwork/java/javase/overview/index.html)
* [Java Platform SE 6 API](http://www.runoob.com/manual/jdk1.6/overview-summary.html)
* [Java Platform SE 7 API](http://docs.oracle.com/javase/7/docs/api/)
* [Java Platform SE 8 API](http://docs.oracle.com/javase/8/docs/api/)
* [Java Platform Standard Edition 8 Documentation](http://docs.oracle.com/javase/8/docs/)
* [Java Language and Virtual Machine Specifications](http://docs.oracle.com/javase/specs/index.html)
* [The Java Language Specification - Java SE 8 Edition](http://docs.oracle.com/javase/specs/jls/se8/html/index.html)
* [The Java Virtual Machine Specification - Java SE 8 Edition](http://docs.oracle.com/javase/specs/jvms/se8/html/index.html)
* [Java SE Downloads](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
* [Oracle Java Archive](http://www.oracle.com/technetwork/java/archive-139210.html)

* [Eclipse IDE for Java Developers](http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/neon2)
* [NetBeans IDE](https://netbeans.org/index.html)

* [Java Community Process](https://www.jcp.org)
* [Java version history](https://en.wikipedia.org/wiki/Java_version_history)
* [Java connects to MySQL](https://dev.mysql.com/downloads/connector/j/)
* [Java Language Wikipedia](https://en.wikipedia.org/wiki/Java_%28programming_language%29)
* [Comparison of Java and C++](https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B)
* [Java Tutorial](http://www.runoob.com/java/java-tutorial.html)
* [OpenJDK](http://openjdk.java.net/)
* [Permissions in the Java 2 Standard Edition Development Kit (JDK)](http://docs.oracle.com/javase/1.5.0/docs/guide/security/permissions.html)

* [The Java Tutorials](http://docs.oracle.com/javase/tutorial/index.html)
* [Java Fundamental Classes Reference](https://www.cs.ait.ac.th/~on/O/oreilly/java/fclass/index.htm)
* [Javadoc Tool Documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html)
* [Oracle Technology Network for Java Developers](http://www.oracle.com/technetwork/java/index.html)
* [IBM developerWorks](https://www.ibm.com/developerworks/cn/)
* [Bruce Eckel's MindView](http://mindviewinc.com/Index.php)
* [ONJava.com](http://www.onjava.com/)
* [Java.net](https://community.oracle.com/community/java)
* [JUnit](http://junit.org/junit4/)
