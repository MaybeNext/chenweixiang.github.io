---
layout: post
title: "C++"
tag: Programming Language
toc: true
---

This article introduces the **C++** programming language.

<!--more-->

# Overview

**C++**, high-level computer programming language. Developed by *Bjarne Stroustrup* of Bell Laboratories in the early 1980s, it is based on the traditional **C** language but with added object-oriented programming and other capabilities. C++, along with Java, has become popular for developing commercial software packages that incorporate multiple interrelated applications. C++ is considered one of the fastest languages and is very close to low-level languages, thus allowing complete control over memory allocation and management. This very feature and its many other capabilities also make it one of the most difficult languages to learn and handle on a large scale.

# C++ Standards

Refer to the following links for the C++ standards:

* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html#c-standards-1">C++ Standards</a>
* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)

![C++ standard timeline](/assets/C++-wg21-timeline.png)

Also refer to [News, Status & Discussion about Standard C++](https://isocpp.org/).

# C++ Language

## Keywords

This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.

|     Keywords     |  Standard   |
| :--------------- | :---------: |
| alignas          | since C++11 |
| alignof          | since C++11 |
| and              |             |
| and_eq           |             |
| asm              |             |
| atomic_cancel    | TM TS       |
| atomic_commit    | TM TS       |
| atomic_noexcept  | TM TS       |
| auto             | (1)         |
| bitand           |             |
| bitor            |             |
| bool             |             |
| break            |             |
| case             |             |
| catch            |             |
| char             |             |
| char16_t         | since C++11 |
| char32_t         | since C++11 |
| class            | (1)         |
| compl            |             |
| concept          | concepts TS |
| const            |             |
| constexpr        | since C++11 |
| const_cast       |             |
| continue         |             |
| decltype         | since C++11 |
| default          | (1)         |
| delete           | (1)         |
| do               |             |
| double           |             |
| dynamic_cast     |             |
| else             |             |
| enum             |             |
| explicit         |             |
| export           | (1)         |
| extern           | (1)         |
| false            |             |
| float            |             |
| for              |             |
| friend           |             |
| goto             |             |
| if               |             |
| import           | modules TS  |
| inline           | (1)         |
| int              |             |
| long             |             |
| module           | modules TS  |
| mutable          | (1)         |
| namespace        |             |
| new              |             |
| noexcept         | since C++11 |
| not              |             |
| not_eq           |             |
| nullptr          | since C++11 |
| operator         |             |
| or               |             |
| or_eq            |             |
| private          |             |
| protected        |             |
| public           |             |
| register         | (2)         |
| reinterpret_cast |             |
| requires         | concepts TS |
| return           |             |
| short            |             |
| signed           |             |
| sizeof           | (1)         |
| static           |             |
| static_assert    | since C++11 |
| static_cast      |             |
| struct           | (1)         |
| switch           |             |
| synchronized     | TM TS       |
| template         |             |
| this             |             |
| thread_local     | since C++11 |
| throw            |             |
| true             |             |
| try              |             |
| typedef          |             |
| typeid           |             |
| typename         |             |
| union            |             |
| unsigned         |             |
| using            | (1)         |
| virtual          |             |
| void             |             |
| volatile         |             |
| wchar_t          |             |
| while            |             |
| xor              |             |
| xor_eq           |             |

<p/>

NOTE:

(1) - meaning changed or new meaning added in **C++11**. Note: the keyword *export* is also used by Modules TS.
(2) - meaning changed in **C++17**.

Note that ```and```, ```bitor```, ```or```, ```xor```, ```compl```, ```bitand```, ```and_eq```, ```or_eq```, ```xor_eq```, ```not```, and ```not_eq``` (along with the digraphs ```<%```, ```%>```, ```<:```, ```:>```, ```%:```, and ```%:%:```) provide an alternative way to represent standard tokens.

## Operators

| Operators                                                                                           | Associativity     |
| :-------------------------------------------------------------------------------------------------- | :---------------: |
| ```()``` ```[]``` ```->``` ```.```                                                                  | left to right     |
| ```!``` ```~``` ```++``` ```--``` ```+``` ```-``` ```(type)``` ```*``` ```&``` ```sizeof```         | **right to left** |
| ```*``` ```/``` ```%```                                                                             | left to right     |
| ```+``` ```-```                                                                                     | left to right     |
| ```<<``` ```>>```                                                                                   | left to right     |
| ```<``` ```<=``` ```>``` ```>=```                                                                   | left to right     |
| ```==``` ```!=```                                                                                   | left to right     |
| ```&```                                                                                             | left to right     |
| ```^```                                                                                             | left to right     |
| ```|```                                                                                             | left to right     |
| ```&&```                                                                                            | left to right     |
| ```||```                                                                                            | left to right     |
| ```?:```                                                                                            | **right to left** |
| ```=``` ```+=``` ```-=``` ```*=``` ```/=``` ```%=``` ```<<=``` ```>>=``` ```&=``` ```^=``` ```|=``` | **right to left** |
| ```,```                                                                                             | left to right     |

<p/>

Run the following command to get the operator priority under Linux environment:

```
chenwx@chenwx ~ $ man operator

NAME
       operator - C operator precedence and order of evaluation

DESCRIPTION
       This manual page lists C operators and their precedence in evaluation.

       Operator                             Associativity
       () [] -> .                           left to right
       ! ~ ++ -- + - (type) * & sizeof      right to left
       * / %                                left to right
       + -                                  left to right
       << >>                                left to right
       < <= > >=                            left to right
       == !=                                left to right
       &                                    left to right
       ^                                    left to right
       |                                    left to right
       &&                                   left to right
       ||                                   left to right
       ?:                                   right to left
       = += -= *= /= %= <<= >>= &= ^= |=    right to left
       ,                                    left to right

COLOPHON
       This page is part of release 3.54 of the Linux man-pages project.  A description of the project, and information about reporting bugs, can befound at http://www.kernel.org/doc/man-pages/.
```

## Comments

## Data Types

## Classes

### class

#### 类的构造函数

* 构造函数与类同名，且无返回类型。
* C++语言对于一个类可以声明多少个构造函数没有限制，只要每个构造函数的参数表是惟一的即可。
* 缺省构造函数是指不需要用户指定实参就能够被调用的构造函数，这并不意味着它不能接受实参，只意味着构造函数的每个参数都有一个缺省值与之关联。
* 构造函数的可访问性由其声明所在的访问区来决定。若把构造函数放到非公有访问区内，从而会限制或显式禁止某些形式的对象创建动作。
* 用一个类对象初始化该类的另一个对象被称为缺省按成员初始化。在概念上，一个类对象向该类的另一个对象作拷贝是通过依次拷贝每个非静态数据成员来实现的。类的设计者也可以通过提供特殊的拷贝构造函数来改变缺省的行为。如果定义了拷贝构造函数，则在用一个类对象初始化该类另一个对象时它就会被调用。

构造函数的调用顺序总是如下:

1. **基类构造函数**。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
2. **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
3. **派生类构造函数**。作为一般规则，派生类构造函数应该不能直接向一个基类数据成员赋值，给适当的基类构造函数。

#### 类的析构函数

* 析构函数是一个特殊的、由用户定义的成员函数，当该类的对象离开了它的域，或者delete表达式应用到一个该类的对象的指针上时，析构函数会自动被调用。
* 析构函数的名字是在类名前加上波浪线（~），它不返回任何值，也没有任何参数。因为它不能指定任何参数，因而它也不能被重载。
* 尽管我们可以为一个类定义多个构造函数，但是我们只能提供一个析构函数，它将被应用在类的所有对象上。

派生类的析构函数调用顺序与它的构造函数调用顺序相反，因而析构函数的调用顺序如下：

1. **派生类析构函数**
2. **成员类对象析构函数**
3. **基类析构函数**

#### 静态成员变量

静态成员变量被当作类的全局对象。对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量对每个类类型只有一个拷贝。**静态成员变量只有一份，由该类类型的所有对象共享访问。**

同全局对象相比，使用静态成员变量有两个优势：
1. 静态成员变量没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性；
2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局对象不能。

在类体中的成员变量声明前面加上关键字static就使该成员变量成为静态的。static成员变量遵从public, private, protected访问规则。

静态成员变量在该类定义之外被初始化，如同一个成员函数被定义在类定义之外一样，在这种定义中的静态成员变量的名字必须被其类名限定修饰，例如：

```
#include "account.h"
double Account::_interestRate = 0.0589;
```

与全局对象一样，对于静态成员变量，在程序中也只能提供一个定义。这意味着，静态成员变量的初始化不应该被放在头文件中，而应该放在含有类的非inline函数定义的文件中。静态成员变量可以被声明为任意类型，它们可以是const对象、数组或类对象等。

#### 多态性

* 用virtual关键字声明的函数叫做虚函数，虚函数肯定是类的成员函数。
* 包含虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
* **多态性是一个接口多种实现**，是面向对象的核心。分为**类的多态性**和**函数的多态性**。
* **多态用虚函数来实现，结合动态绑定**。
* 虚函数只能借助于指针或者引用来达到多态的效果。
* 纯虚函数是虚函数再加上=0。
* 抽象类是指包括至少一个纯虚函数的类。

### struct

The class keys ```struct``` and ```class``` are indistinguishable in C++, except that the *default access mode* and *default inheritance mode* are **public** if class declaration uses the **struct** class-key and **private** if the class declaration uses the **class** class-key. Both class and struct can be used in a class definition.

### union

The use of the class key ```union``` results in a union definition, which defines a class that holds only one of its data members at a time.

# Comparison of C and C++

# C++ Standard Library

* [Current Status of C++ Standard](https://isocpp.org/std/status)

## C++ Compiler Support

Refer to [C++ compiler support](http://en.cppreference.com/w/cpp/compiler_support).

# Coliru Online Compiler

[Coliru Online Compiler](http://coliru.stacked-crooked.com/)

# C++ FAQ

## 字节序(Endianness)

![Endian的由来](http://www.eygle.com/digest/2007/01/whats_mean_endian.html)

对于单一的字节(a byte)，大部分处理器以相同的顺序处理比特位(bit)，因此单字节的存放方法和传输方式一般是相同的。

字节序是指存放多字节数据的字节(byte)的顺序，典型的情况是整数在内存中的存放方式和网络传输的传输顺序。Endianness有时候也可以用指位序(bit)。

一般而言，字节序指示了一个UCS-2字符的哪个字节存储在低地址。如果LSByte在MSByte的前面，即LSB为低地址，则该字节序是**小端序**；反之则是**大端序**。在网络编程中，字节序是一个必须被考虑的因素，因为不同的处理器体系可能采用不同的字节序。在多平台的代码编程中，字节序可能会导致难以察觉的bug。

* Big-endian

![Big-endian](/assets/big-endian.png)

* Little-endian

![Little-endian](/assets/little-endian.png)

### 处理器体系

* x86, MOS Technology 6502, Z80, VAX, PDP-11等处理器为Little endian。
* Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC (除V9外)等处理器为Big endian。
* ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。

### 网络序

网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。

伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl(), htons()用于本机序转换到网络序；ntohl(), ntohs()用于网络序转换到本机序。


## VC字节对齐规则

关键字：

```
#pragma pack(n)
#pragma pack()
```

* 结构体中变量的偏移

    * 默认情况下，VC规定，结构体各成员变量存放的起始地址相对于结构体的起始地址的偏移量，必须为该变量的类型所占用的字节数的整数倍。
    * 若n大于等于该变量的类型所占用的字节数，则偏移量必须满足默认的字节对齐方式。
    * 若n小于该变量的类型所占用的字节数，则偏移量为n的整数倍，不用满足默认的对齐方式。

* 结构体总大小的约束

    * 若n大于所有成员变量的类型所占用的字节数，则结构体总大小必须为占用空间最大的成员变量所占用空间的整数倍；否则，必须为n的整数倍。
    * 所有因为偏移而引起的字节空缺，将由VC自动填补，没有放置任何有意义的东西。

# Books

* **C++ Primer, 3rd Edition**

# References

* [News, Status & Discussion about Standard C++](https://isocpp.org/)
* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html">Linux: C/C++ Libraries</a>
* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)
* [JTC1/SC22/WG21 - Papers 2011](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/)
* [C++0x FAQ](http://www2.research.att.com/~bs/C++0xFAQ.html)
* [C++ programming language on Wikipedia](https://en.wikipedia.org/wiki/C%2B%2B)

* [C/C++ Reference](http://en.cppreference.com/w/)
