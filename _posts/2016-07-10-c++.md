---
layout: post
title: "C++"
tag: Programming Languages
toc: true
---

This article introduces the **C++** programming language.

<!--more-->

# Overview

**C++**, high-level computer programming language. Developed by *Bjarne Stroustrup* of Bell Laboratories in the early 1980s, it is based on the traditional **C** language but with added object-oriented programming and other capabilities. C++, along with Java, has become popular for developing commercial software packages that incorporate multiple interrelated applications. C++ is considered one of the fastest languages and is very close to low-level languages, thus allowing complete control over memory allocation and management. This very feature and its many other capabilities also make it one of the most difficult languages to learn and handle on a large scale.

# C++ Standards

![C++ Language Evolution](/assets/CPP_Language_Evolution.png)

C++ is standardized by the International Organization for Standardization (ISO) [C++ Standards Committee (JTC1/SC22/WG21 - C++)](http://www.open-std.org/jtc1/sc22/wg21/). So far, it has seen following versions of C++ released. Besides, the C++ standards committee publishes [experimental C++ language and library extensions](http://en.cppreference.com/w/cpp/experimental) for future standardization.

* **ISO/IEC 14882:1998 (C++98)**

    In 1998, the ISO working group standardized C++ for the first time as **ISO/IEC 14882:1998**, which is informally known as **C++98**.

* **ISO/IEC 14882:2003 (C++03)**

    In 2003, ISO working group published a new version of the C++ standard called **ISO/IEC 14882:2003**, which is informally known as **C++03**. This version of the C++ standard fixed problems identified in **C++98**.

* **ISO/IEC TR 18015:2006** - Technical Report on C++ Performance

    The aim of ISO/IEC TR 18015 is to:

    * give the reader a model of time and space overheads implied by use of various C++ language and library features;
    * debunk widespread myths about performance problems in C++;
    * present techniques for use of C++ in applications where performance matters; and
    * present techniques for implementing C++ standard language and library facilities to yield efficient code.
    <p/>
    The special needs of embedded systems programming are presented, including ROMability and predictability. A separate chapter presents general C and C++ interfaces to the basic hardware facilities of embedded systems.

* **ISO/IEC TR 19768:2007 (C++TR1)** - Technical Report on C++ Library Extensions

    In 2007, a technical report **ISO/IEC TR 19768:2007 - C++ Library Extensions** was released, which is informally known as **C++07/TR1**. While not an official part of the standard, it proposed a number of extensions to the standard library.

* **ISO/IEC TR 29124:2010** - Extensions to the C++ Library to support mathematical special functions

    In 2010, a technical report **ISO/IEC TR 29124:2010 - C++ Special Math Functions** is released. The draft can be found [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf).

* **ISO/IEC 14882:2011 (C++11)**

    In 2011, a major revision of the standard was informally referred to as ***C++0x***, but it was not released until 2011. The **ISO/IEC 14882:2011 (C++11)** included most of the library enhancements of **C++07/TR1**, as well as many additions to the core language.

* **ISO/IEC TR 24733:2011** - Extensions for the programming language C++ to support decimal floating-point arithmetic

    In 2011, a technical report **ISO/IEC TR 24733:2011 - C++ decimal floating point arithmetic extensions** is released. The draft can be found [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2849.pdf).

* **ISO/IEC 14882:2014 (C++14)**

    In 2014, **C++14** (also known as ***C++1y***) was released as a small extension to **C++11**, featuring mainly bug fixes and small improvements.

* **ISO/IEC TS 18822:2015** - File System Technical Specification

    ISO/IEC TS 18822:2015 specifies requirements for implementations of an interface that computer programs written in the C++ programming language may use to perform operations on file systems and their components, such as paths, regular files, and directories. This Technical Specification is applicable to information technology systems that can access hierarchical file systems, such as those with operating systems that conform to the POSIX (3) interface. This Technical Specification is applicable only to vendors who wish to provide the interface it describes.

* **ISO/IEC TS 19570:2015** - Technical Specification for C++ Extensions for Parallelism

Also refer to the following links:

* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)
* [News, Status & Discussion about Standard C++](https://isocpp.org/)
* [Current Status of C++ Standard](https://isocpp.org/std/status)

![C++ standard timeline](/assets/C++-wg21-timeline.png)

# C++ Language

## Translation Phases

Refer to [Phases of translation](http://en.cppreference.com/w/cpp/language/translation_phases) on CppReference, the C++ source file is processed by the compiler as if the following phases take place, in this exact order:

### Phase 1

The individual bytes of the source code file are mapped (in implementation-defined manner) to the characters of the *basic source character set*. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The *basic source character set* consists of 96 characters:

* **5 whitespace characters**: space (``` ```), horizontal tab (```\t```), vertical tab (```\v```), form feed (```\f```), new-line (```\n```)
* **10 digit characters**: ```0``` to ```9```
* **52 letters**: ```a``` to ```z```, ```A``` to ```Z```
* **29 punctuation characters**: ```_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '```

Any source file character that cannot be mapped to a character in the *basic source character set* is replaced by its *universal character name* (escaped with ```\u``` or ```\U```) or by some implementation-defined form that is handled equivalently.

**Until C++17**, [trigraph sequences](http://en.cppreference.com/w/cpp/language/operator_alternative) are replaced by corresponding single-character representations:

| Trigraph  | Single-character | Description   |
| :-------: | :--------------: | :------------ |
| ```??<``` | ```{```          | left brace    |
| ```??>``` | ```}```          | right brace   |
| ```??(``` | ```[```          | left bracket  |
| ```??)``` | ```]```          | right bracket |
| ```??=``` | ```#```          | pound sign    |
| ```??/``` | ```\```          | backslash     |
| ```??'``` | ```^```          | caret         |
| ```??!``` | ```|```          | vertical bar  |
| ```??-``` | ```~```          | tilde         |

<p/>

### Phase 2

Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation; a line ending in two backslashes followed by an empty line does not combine three lines into one. If a universal character name ```\uXXX``` is formed in this phase, the behavior is undefined.

If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), (the behavior is undefined, **until C++11**) (a terminating newline character is added, **since C++11**).

### Phase 3

The source file is decomposed into comments, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and preprocessing tokens, which are the following:

* header names: ```<iostream>``` or ```myfile.h```
* identifiers
* preprocessing numbers
* character and string literals , (including user-defined, **since C++11**)
* operators and punctuators (including alternative tokens), such as ```+```, ```<<=```, ```new```, ```<%```, ```##```
* individual non-whitespace characters that do not fit in any other category

**Since C++11**, any transformations performed during **phases 1 and 2** between the initial and the final double quote of any raw string literal are reverted.

Each comment is replaced by one space character.

Note: Newlines are kept, and it's unspecified whether non-newline whitespace sequences may be collapsed into single space characters.

### Phase 4

The preprocessor is executed.

Each file introduced with the ```#include``` directive goes through **phases 1 through 4**, recursively.

At the end of this phase, all preprocessor directives are removed from the source.

### Phase 5

All characters in character literals and string literals are converted from the *source character set* to the *execution character set* (which may be a multibyte character set such as UTF-8, as long as the 96 characters of the basic source character set listed in phase 1 have single-byte representations).

Escape sequences and *universal character names* in character literals and non-raw string literals are expanded and converted to the execution character set. If the character specified by a universal character name isn't a member of the execution character set, the result is implementation-defined, but is guaranteed not to be a null (wide) character.

Note: The conversion performed at this stage can be controlled by command line options in some implementations: **gcc** and **clang** use ```-finput-charset``` to specify the encoding of the *source character set*, ```-fexec-charset``` and ```-fwide-exec-charset``` to specify the encodings of the *execution character set* in the string and character literals (that don't have an encoding prefix, **since C++11**).

### Phase 6

Adjacent string literals are concatenated.

### Phase 7

**Compilation** takes place: each preprocessing token is converted to a token. The tokens are syntactically and semantically analyzed and translated as a translation unit.

### Phase 8

Each translation unit is examined to produce a list of required template instantiations, including the ones requested by explicit instantiations. The definitions of the templates are located, and the required instantiations are performed to produce **instantiation units**.

### Phase 9

Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.

Note: Some compilers don't implement *instantiation units* (also known as [template repositories(http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc) or [template registries](https://www.ibm.com/support/knowledgecenter/en/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html)) and simply compile each template instantiation at **Phase 7**, storing the code in the object file where it is implicitly or explicitly requested, and then the linker collapses these compiled instantiations into one at **Phase 9**.

## Keywords

This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading. Also refer to [C++ Keywords Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_keywords.html).

|     Keywords     |  Standard   |
| :--------------- | :---------: |
| alignas          | since C++11 |
| alignof          | since C++11 |
| and              |             |
| and_eq           |             |
| asm              |             |
| atomic_cancel    | TM TS       |
| atomic_commit    | TM TS       |
| atomic_noexcept  | TM TS       |
| auto             | (1)         |
| bitand           |             |
| bitor            |             |
| bool             |             |
| break            |             |
| case             |             |
| catch            |             |
| char             |             |
| char16_t         | since C++11 |
| char32_t         | since C++11 |
| class            | (1)         |
| compl            |             |
| concept          | concepts TS |
| const            |             |
| constexpr        | since C++11 |
| const_cast       |             |
| continue         |             |
| decltype         | since C++11 |
| default          | (1)         |
| delete           | (1)         |
| do               |             |
| double           |             |
| dynamic_cast     |             |
| else             |             |
| enum             |             |
| explicit         |             |
| export           | (1)         |
| extern           | (1)         |
| false            |             |
| float            |             |
| for              |             |
| friend           |             |
| goto             |             |
| if               |             |
| import           | modules TS  |
| inline           | (1)         |
| int              |             |
| long             |             |
| module           | modules TS  |
| mutable          | (1)         |
| namespace        |             |
| new              |             |
| noexcept         | since C++11 |
| not              |             |
| not_eq           |             |
| nullptr          | since C++11 |
| operator         |             |
| or               |             |
| or_eq            |             |
| private          |             |
| protected        |             |
| public           |             |
| register         | (2)         |
| reinterpret_cast |             |
| requires         | concepts TS |
| return           |             |
| short            |             |
| signed           |             |
| sizeof           | (1)         |
| static           |             |
| static_assert    | since C++11 |
| static_cast      |             |
| struct           | (1)         |
| switch           |             |
| synchronized     | TM TS       |
| template         |             |
| this             |             |
| thread_local     | since C++11 |
| throw            |             |
| true             |             |
| try              |             |
| typedef          |             |
| typeid           |             |
| typename         |             |
| union            |             |
| unsigned         |             |
| using            | (1)         |
| virtual          |             |
| void             |             |
| volatile         |             |
| wchar_t          |             |
| while            |             |
| xor              |             |
| xor_eq           |             |

<p/>

NOTE:

* (1) - meaning changed or new meaning added in **C++11**. Note: the keyword *export* is also used by Modules TS.
* (2) - meaning changed in **C++17**.

Note that ```and```, ```bitor```, ```or```, ```xor```, ```compl```, ```bitand```, ```and_eq```, ```or_eq```, ```xor_eq```, ```not```, and ```not_eq``` (along with the digraphs ```<%```, ```%>```, ```<:```, ```:>```, ```%:```, and ```%:%:```) provide an alternative way to represent standard tokens.

### Alternative Tokens

There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the stringification operator can make the spelling visible). The two-letter alternative tokens are sometimes called **digraphs**:

| Primary  | Alternative |
| :------: | :---------- |
| ```&&``` | and         |
| ```&=``` | and_eq      |
| ```&```  | bitand      |
| ```|```  | bitor       |
| ```~```  | compl       |
| ```!```  | not         |
| ```!=``` | not_eq      |
| ```||``` | or          |
| ```|=``` | or_eq       |
| ```^```  | xor         |
| ```^=``` | xor_eq      |
| ```{```  | ```<%```    |
| ```}```  | ```%>```    |
| ```[```  | ```<:```    |
| ```]```  | ```:>```    |
| ```#```  | ```%:```    |
| ```##``` | ```%:%:```  |

<p/>

## Identifiers

### Identifiers Constitution

An *identifier* is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and most Unicode characters. A valid identifier must begin with a non-digit character (Latin letter, underscore, or Unicode non-digit character). Identifiers are case-sensitive, and **every character is significant**.

### Reserved Identifiers

An *identifier* can be used to name objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:

* the identifiers that are keywords cannot be used for other purposes;
* the identifiers with a double underscore anywhere are reserved;
* the identifiers that begin with an underscore followed by an uppercase letter are reserved;
* the identifiers that begin with an underscore are reserved in the global namespace.

**Reserved** here means that the standard library headers ```#define``` or declare such identifiers for their internal needs, the compiler may predefine non-standard identifiers of that kind, and that name mangling algorithm may assume that some of these identifiers are not in use. If the programmer uses such identifiers, the behavior is undefined.

In addition, it's undefined behavior to ```#define``` or ```#undef``` names identical to [keywords](#keywords). If at least one standard library header is included, it's undefined behavior to ```#define``` or ```#undef``` identifiers identical to names declared in any standard library header.

### Translation Limits

## Operators

Refer to [C++ Operators Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_operators.html).

| Operators                                                                                           | Associativity     |
| :-------------------------------------------------------------------------------------------------- | :---------------: |
| ```()``` ```[]``` ```->``` ```.```                                                                  | left to right     |
| ```!``` ```~``` ```++``` ```--``` ```+``` ```-``` ```(type)``` ```*``` ```&``` ```sizeof```         | **right to left** |
| ```*``` ```/``` ```%```                                                                             | left to right     |
| ```+``` ```-```                                                                                     | left to right     |
| ```<<``` ```>>```                                                                                   | left to right     |
| ```<``` ```<=``` ```>``` ```>=```                                                                   | left to right     |
| ```==``` ```!=```                                                                                   | left to right     |
| ```&```                                                                                             | left to right     |
| ```^```                                                                                             | left to right     |
| ```|```                                                                                             | left to right     |
| ```&&```                                                                                            | left to right     |
| ```||```                                                                                            | left to right     |
| ```?:```                                                                                            | **right to left** |
| ```=``` ```+=``` ```-=``` ```*=``` ```/=``` ```%=``` ```<<=``` ```>>=``` ```&=``` ```^=``` ```|=``` | **right to left** |
| ```,```                                                                                             | left to right     |

<p/>

Run the following command to get the operator priority under Linux environment:

```
chenwx@chenwx ~ $ man operator

NAME
       operator - C operator precedence and order of evaluation

DESCRIPTION
       This manual page lists C operators and their precedence in evaluation.

       Operator                             Associativity
       () [] -> .                           left to right
       ! ~ ++ -- + - (type) * & sizeof      right to left
       * / %                                left to right
       + -                                  left to right
       << >>                                left to right
       < <= > >=                            left to right
       == !=                                left to right
       &                                    left to right
       ^                                    left to right
       |                                    left to right
       &&                                   left to right
       ||                                   left to right
       ?:                                   right to left
       = += -= *= /= %= <<= >>= &= ^= |=    right to left
       ,                                    left to right

COLOPHON
       This page is part of release 3.54 of the Linux man-pages project.  A description of the project, and information about reporting bugs, can befound at http://www.kernel.org/doc/man-pages/.
```

## Comments

**C-style comments** or **multi-line comments**, which cannot be nested.

```
/* comment */
```

**C++-style comments** or **single-line comments** (since **C99**), which can be nested.

```
// comment until end of the line
```

All comments are removed from the program at [translation phase 3](#phase-3) by replacing each comment with a single whitespace character.

Because comments are removed before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an ```#include```'d file.

Besides commenting out, other mechanisms used for source code exclusion are:

```
#if 0
    std::cout << "this will not be executed or even compiled\n";
#endif
```

and

```
if (false)
{
    std::cout << "this will not be executed\n"
}
```

## Types

The C++ type system consists of [Fundamental Types](#fundamental-types) and [Compound Types](#compound-types), refer to [C++ Types](http://en.cppreference.com/w/cpp/language/type) on CppReference.

### Fundamental Types

std::is_fundamental is defined in header ```<type_traits>```:

```
template< class T >
struct is_fundamental;    (since C++11)
```

If *T* is a fundamental type (that is, *arithmetic type*, *void*, or *nullptr_t*), provides the member constant value equal ```true```. For any other type, value is ```false```:

```
#include <iostream>
#include <type_traits>

class A {};

int main()
{
    std::cout << std::boolalpha;
    std::cout << std::is_fundamental<A>::value << '\n';
    std::cout << std::is_fundamental<int>::value << '\n';
    std::cout << std::is_fundamental<int&>::value << '\n';
    std::cout << std::is_fundamental<int*>::value << '\n';
    std::cout << std::is_fundamental<float>::value << '\n';
    std::cout << std::is_fundamental<float&>::value << '\n';
    std::cout << std::is_fundamental<float*>::value << '\n';
}
```

#### void

std::is_void is defined in header ```<type_traits>```:

```
template< class T >
struct is_void;        (since C++11)
```

Checks whether *T* is a void type. Provides the member constant value that is equal to ```true```, if *T* is the type *void*, *const void*, *volatile void*, or *const volatile void*. Otherwise, value is equal to ```false```.

```
#include <iostream>
#include <type_traits>

int main()
{
    std::cout << std::boolalpha;
    std::cout << std::is_void<void>::value << '\n';
    std::cout << std::is_void<int>::value << '\n';
}
```

#### std::nullptr_t

Since **C++11**:

The keyword ```nullptr``` denotes the pointer literal. It is a *prvalue* of type *std::nullptr_t*. There exist implicit conversions from ```nullptr``` to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type *std::nullptr_t* as well as the macro ```NULL```.

*std::nullptr_t* is the type of the null pointer literal, *nullptr*. It is a distinct type that is not itself a pointer type or a pointer to member type.

```
#include <cstddef>
#include <iostream>

void f(int* pi)
{
   std::cout << "Pointer to integer overload\n";
}

void f(double* pd)
{
   std::cout << "Pointer to double overload\n";
}

void f(std::nullptr_t nullp)
{
   std::cout << "null pointer overload\n";
}

int main()
{
    int* pi; double* pd;

    // call void f(int* pi)
    f(pi);

    // call void f(double* pd)
    f(pd);

    // would be ambiguous without void f(nullptr_t)
    f(nullptr);

    // ambiguous overload: all three functions are candidates
    // f(NULL);
}
```

*std::is_null_pointer* is defined in header ```<type_traits>```:

```
template< class T >
struct is_null_pointer;    (since C++14)
```

Checks whether *T* is the type *std::nullptr_t*. Provides the member constant value that is equal to true, if *T* is the type *std::nullptr_t*, *const std::nullptr_t*, *volatile std::nullptr_t*, or *const volatile std::nullptr_t*. Otherwise, value is equal to ```false```.

```
#include <iostream>
#include <type_traits>

int main()
{
    std::cout << std::boolalpha
              << std::is_null_pointer< decltype(nullptr) >::value << ' '
              << std::is_null_pointer< int* >::value << '\n'
              << std::is_pointer< decltype(nullptr) >::value << ' '
              << std::is_pointer<int*>::value << '\n';
}
```

### Compound Types

## Classes

Classes provide the four features commonly present in Object-Oriented Programming (OOP) languages: **abstraction**, **encapsulation**, **inheritance**, and **polymorphism**.

### 抽象 / Abstraction

### 封装 / Encapsulation

Encapsulation is the hiding of information to ensure that data structures and operators are used as intended and to make the usage model more obvious to the developer. C++ provides the ability to define classes and functions as its primary encapsulation mechanisms. Within a class, members can be declared as either **public**, **protected**, or **private** to explicitly enforce encapsulation.

* A **public** member of the class is accessible to any function.
* A **private** member is accessible only to functions that are members of that class and to functions and classes explicitly granted access permission by the class (**friends**).
* A **protected** member is accessible to members of classes that inherit from the class in addition to the class itself and any friends.

It is generally considered good practice to make all data private or protected, and to make public only those functions that are part of a minimal interface for users of the class. This can hide the details of data implementation, allowing the designer to later fundamentally change the implementation without changing the interface in any way.

### 继承 / Inheritance

**Inheritance allows one data type to acquire properties of other data types.**

Inheritance from a base class may be declared as **public**, **protected**, or **private**. This access specifier determines whether unrelated and derived classes can access the inherited public and protected members of the base class. Only public inheritance corresponds to what is usually meant by *inheritance*. The other two forms are much less frequently used. If the access specifier is omitted, a **class** inherits privately, while a **struct** inherits publicly.

Base classes may be declared as virtual; this is called **virtual inheritance**. Virtual inheritance ensures that only one instance of a base class exists in the inheritance graph, avoiding some of the ambiguity problems of multiple inheritance.

**Multiple inheritance** is a C++ feature not found in most other languages, allowing a class to be derived from more than one base class; this allows for more elaborate inheritance relationships.

### 多态 / Polymorphism

Polymorphism enables one common interface for many implementations, and for objects to act differently under different circumstances.

C++ supports several kinds of **static** (resolved at *compile-time*) and **dynamic** (resolved at *runtime*) polymorphisms. Compile-time polymorphism does not allow for certain run-time decisions, while runtime polymorphism typically incurs a performance penalty.

**Static Polymorphism**

* **Function overloading** allows programs to declare multiple functions having the same name but with different arguments. The functions are distinguished by the number or types of their formal parameters. Thus, the same function name can refer to different functions depending on the context in which it is used. The type returned by the function is not used to distinguish overloaded functions and would result in a compile-time error message.

* **Templates** in C++ provide a sophisticated mechanism for writing generic, polymorphic code.

**Dynamic Polymorphism**

* **Inheritance**: Variable pointers and references to a base class type in C++ can also refer to objects of any derived classes of that type. This allows arrays and other kinds of containers to hold pointers to objects of differing types. This enables dynamic (run-time) polymorphism, where the referred objects can behave differently depending on their (actual, derived) types.

* **Virtual member functions**: When a function in a derived class *overrides* a function in a base class, the function to call is determined by the type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called *dynamic dispatch*. Virtual member functions allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using **virtual function tables**. If the object type is known, this may be bypassed by prepending a *fully qualified class name* before the function call, but in general calls to virtual functions are resolved at run time.

Notes:

* 用virtual关键字声明的函数叫做虚函数，虚函数肯定是类的成员函数。
* 包含虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
* **多态性是一个接口多种实现**，是面向对象的核心。分为**类的多态性**和**函数的多态性**。
* **多态用虚函数来实现，结合动态绑定**。
* 虚函数只能借助于指针或者引用来达到多态的效果。
* 纯虚函数是虚函数再加上=0。
* 抽象类是指包括至少一个纯虚函数的类。

### 构造函数 / Constructors

* 构造函数与类同名，且无返回类型。
* C++语言对于一个类可以声明多少个构造函数没有限制，只要每个构造函数的参数表是惟一的即可。
* 缺省构造函数是指不需要用户指定实参就能够被调用的构造函数，这并不意味着它不能接受实参，只意味着构造函数的每个参数都有一个缺省值与之关联。
* 构造函数的可访问性由其声明所在的访问区来决定。若把构造函数放到非公有访问区内，从而会限制或显式禁止某些形式的对象创建动作。
* 用一个类对象初始化该类的另一个对象被称为缺省按成员初始化。在概念上，一个类对象向该类的另一个对象作拷贝是通过依次拷贝每个非静态数据成员来实现的。类的设计者也可以通过提供特殊的拷贝构造函数来改变缺省的行为。如果定义了拷贝构造函数，则在用一个类对象初始化该类另一个对象时它就会被调用。

构造函数的调用顺序总是如下:

1. **基类构造函数**。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
2. **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
3. **派生类构造函数**。作为一般规则，派生类构造函数应该不能直接向一个基类数据成员赋值，给适当的基类构造函数。

### 析构函数 / Destructors

* 析构函数是一个特殊的、由用户定义的成员函数，当该类的对象离开了它的域，或者delete表达式应用到一个该类的对象的指针上时，析构函数会自动被调用。
* 析构函数的名字是在类名前加上波浪线（~），它不返回任何值，也没有任何参数。因为它不能指定任何参数，因而它也不能被重载。
* 尽管我们可以为一个类定义多个构造函数，但是我们只能提供一个析构函数，它将被应用在类的所有对象上。

派生类的析构函数调用顺序与它的构造函数调用顺序相反，因而析构函数的调用顺序如下：

1. **派生类析构函数**
2. **成员类对象析构函数**
3. **基类析构函数**

### 静态成员变量 / Static Member Variables

静态成员变量被当作类的全局对象。对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量对每个类类型只有一个拷贝。**静态成员变量只有一份，由该类类型的所有对象共享访问。**

同全局对象相比，使用静态成员变量有两个优势：
1. 静态成员变量没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性；
2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局对象不能。

在类体中的成员变量声明前面加上关键字static就使该成员变量成为静态的。static成员变量遵从public, private, protected访问规则。

静态成员变量在该类定义之外被初始化，如同一个成员函数被定义在类定义之外一样，在这种定义中的静态成员变量的名字必须被其类名限定修饰，例如：

```
#include "account.h"
double Account::_interestRate = 0.0589;
```

与全局对象一样，对于静态成员变量，在程序中也只能提供一个定义。这意味着，静态成员变量的初始化不应该被放在头文件中，而应该放在含有类的非inline函数定义的文件中。静态成员变量可以被声明为任意类型，它们可以是const对象、数组或类对象等。

## struct

The class keys ```struct``` and ```class``` are indistinguishable in C++, except that the *default access mode* and *default inheritance mode* are **public** if class declaration uses the **struct** class-key and **private** if the class declaration uses the **class** class-key. Both class and struct can be used in a class definition.

位结构是一种特殊的结构，在需要按位访问一个字节或字的多个比特位时，位结构比按位运算符更加方便。位结构定义的一般形式为:

```
struct 位结构名
{
    数据类型 变量名: 整型常数;
    数据类型 变量名: 整型常数;
} 位结构变量;
```

其中: 数据类型必须是int (unsigned or signed)。整型常数必须是非负的整数，表示二进制位的个数，即表示有多少位。变量名是可选项，可以不命名, 这样规定是为了排列需要。

例如：

```
struct
{
    unsigned incon: 8;      /*incon占用低字节的0~7位，共8位*/
    unsigned txcolor: 4;	/*txcolor占用高字节的0~3位，共4位*/
    unsigned bgcolor: 3;	/*bgcolor占用高字节的4~6位，共3位*/
    unsigned blink: 1;  	/*blink占用高字节的第7位*/
} ch;
```

位结构成员的访问与结构成员的访问相同。例如: 访问上例位结构中的bgcolor成员可写成```ch.bgcolor```。注意:

1. 位结构中的成员可以定义为unsigned，也可定义为signed，但当成员长度为1时，会被认为是unsigned类型，因为单个位不可能具有符号。
2. 位结构中的成员不能使用数组和指针，但位结构变量可以是数组和指针，如果是指针，其成员访问方式同结构指针。
3. 位结构总长度(位数)，是各个位成员定义的位数之和，可以超过两个字节。
4. 位结构成员可以与其它结构成员一起使用。
5. 一个位域必须存储在同一个字节中，不能跨两个字节。若一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进制位。例如：

```
struct bs    
{    
    unsigned a:4
    unsigned :0 	/*空域*/
    unsigned b:4 	/*从下一单元开始存放*/
    unsigned c:4
}
```

For instance:

```
struct info
{
    char name[8];
    int age;
    struct addr address;
    float pay;
    unsigned state: 1;
    unsigned pay: 1;
} workers;
```

上例的结构定义了关于一个工人的信息。其中有两个位结构成员, 每个位结构成员只有一位, 因此只占一个字节但保存了两个信息, 该字节中第一位表示工人的状态, 第二位表示工资是否已发放。由此可见使用位结构可以节省存贮空间。

## union

The use of the class key ```union``` results in a union definition, which defines a class that holds only one of its data members at a time.

# Comparison of C and C++

Refer to [C vs. C++](http://www.diffen.com/difference/C_vs_C%2B%2B).

# C++ Libraries

## C++ Standard Library

Refer to [C++ Standard Library Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_standlib.html), which is abbreviated to contain only the most frequently used items. The information included here is not meant to be complete or definitive in any way, but more of a quick reference or quick reminder of what something looks like if you need to look it up in a hurry, and you've left your handy hard-copy reference on the bus. Thus, infrequently used functions (or variations of functions) and other entities may not appear.

Also refer to [C++ Standard Library header files](http://en.cppreference.com/w/cpp/header).

**Utilities Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cstdlib**\> | | General purpose utilities: program control, dynamic memory allocation, random numbers, sort and search |
| \<**csignal**\> | | Functions and macro constants for signal management |
| \<**csetjmp**\> | | Macro (and function) that saves (and jumps) to an execution context |
| \<**cstdarg**\> | | Handling of variable length argument lists |
| \<**typeinfo**\> | | Runtime type information utilities |
| \<**typeindex**\> | since C++11 | *std::type_index* |
| \<**type_traits**\> | since C++11 | Compile-time type information |
| \<**bitset**\> | | *std::bitset* class template |
| \<**functional**\> | | Function objects, designed for use with the standard algorithms |
| \<**utility**\> | | Various utility components |
| \<**ctime**\> | | C-style time/date utilites |
| \<**chrono**\> | since C++11 | C++ time utilites |
| \<**cstddef**\> | | typedefs for types such as *size_t*, *NULL* and others |
| \<**initializer_list**\> | since C++11 | *std::initializer_list* class template |
| \<**tuple**\> | since C++11 | *std::tuple* class template |
| \<**any**\> | since C++17 | *std::any* class template |
| \<**optional**\> | since C++17 | *std::optional* class template |
| \<**variant**\> | since C++17 | *std::variant* class template |

<p/>

**Dynamic Memory Management**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**new**\> | | Low-level memory management utilities |
| \<**memory**\> | | Higher level memory management utilities |
| \<**scoped_allocator**\> | since C++11 | Nested allocator class |
| \<**memory_resource**\> | since C++17 | Polymorphic allocators and memory resources |

<p/>

**Numeric Limits**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**climits**\> | | limits of integral types |
| \<**cfloat**\> | | limits of float types |
| \<**cstdint**\> | since C++11 | fixed-size types and limits of other types |
| \<**cinttypes**\> | since C++11 | formatting macros, *intmax_t* and *uintmax_t* math and conversions |
| \<**limits**\> | | standardized way to query properties of arithmetic types |

<p/>

**Error Handling**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**exception**\> | | Exception handling utilities |
| \<**stdexcept**\> | | Standard exception objects |
| \<**cassert**\> | | Conditionally compiled macro that compares its argument to zero |
| \<**system_error**\> | since C++11 | defines *std::error_code*, a platform-dependent error code |
| \<**cerrno**\> | | Macro containing the last error number |

<p/>

**Strings Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cctype**\> | | functions to determine the type contained in character data |
| \<**cwctype**\> | | functions for determining the type of wide character data |
| \<**cstring**\> | | various narrow character string handling functions |
| \<**cwchar**\> | | various wide and multibyte string handling functions |
| \<**cuchar**\> | since C++11 | C-style Unicode character conversion functions |
| \<**string**\> | | *std::basic_string* class template |
| \<**string_view**\> | since C++17 | *std::basic_string_view* class template |

<p/>

**Containers Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**array**\> | since C++11 | *std::array* container |
| \<**vector**\> | | *std::vector* container |
| \<**deque**\> | | *std::deque* container |
| \<**list**\> | | *std::list* container |
| \<**forward_list**\> | since C++11 | *std::forward_list* container |
| \<**set**\> | | *std::set* and *std::multiset* associative containers |
| \<**map**\> | | *std::map* and *std::multimap* associative containers |
| \<**unordered_set**\> | since C++11 | *std::unordered_set* and *std::unordered_multiset* unordered associative containers |
| \<**unordered_map**\> | since C++11 | *std::unordered_map* and *std::unordered_multimap* unordered associative containers |
| \<**stack**\> | | *std::stack container* adaptor |
| \<**queue**\> | | *std::queue* and *std::priority_queue* container adaptors |

<p/>

**Algorithms Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**algorithm**\> | | Algorithms that operate on containers |
| \<**execution**\> | C++17 | Predefined execution policies for parallel versions of the algorithms |

<p/>

**Iterators Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**iterator**\> | | Container iterators |

<p/>

**Numerics Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cmath**\> | | Common mathematics functions |
| \<**complex**\> | | Complex number type |
| \<**valarray**\> | | Class for representing and manipulating arrays of values |
| \<**random**\> | since C++11 | Random number generators and distributions |
| \<**numeric**\> | | Numeric operations on values in containers |
| \<**ratio**\> | since C++11 | Compile-time rational arithmetic |
| \<**cfenv**\> | since C++11 | Floating-point environment access functions |

<p/>

**Input/output Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**iosfwd**\> | | forward declarations of all classes in the input/output library |
| \<**ios**\> | | *std::ios_base* class, *std::basic_ios* class template and several typedefs |
| \<**istream**\> | | *std::basic_istream* class template and several typedefs |
| \<**ostream**\> | | *std::basic_ostream*, *std::basic_iostream* class templates and several typedefs |
| \<**iostream**\> | | several standard stream objects |
| \<**fstream**\> | | *std::basic_fstream*, *std::basic_ifstream*, *std::basic_ofstream* class templates and several typedefs |
| \<**sstream**\> | | *std::basic_stringstream*, *std::basic_istringstream*, *std::basic_ostringstream* class templates and several typedefs |
| \<**strstream**\> | | *std::strstream*, *std::istrstream*, *std::ostrstream* (deprecated) |
| \<**iomanip**\> | | Helper functions to control the format or input and output |
| \<**streambuf**\> | | *std::basic_streambuf* class template |
| \<**cstdio**\> | | C-style input-output functions |

<p/>

**Localization Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**locale**\> | | Localization utilities |
| \<**clocale**\> | | C localization utilities |
| \<**codecvt**\> | since C++11 | Unicode conversion facilities |

<p/>

**Regular Expressions Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**regex**\> | since C++11 | Classes, algorithms and iterators to support regular expression processing |

<p/>

**Atomic Operations Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**atomic**\> | since C++11 | Atomic operations library |

<p/>

**Thread support Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**thread**\> | since C++11 | *std::thread* class and supporting functions |
| \<**mutex**\> | since C++11 | mutual exclusion primitives |
| \<**shared_mutex**\> | since C++14 | shared mutual exclusion primitives |
| \<**future**\> | since C++11 | primitives for asynchronous computations |
| \<**condition_variable**\> | since C++11 | thread waiting conditions |

<p/>

**Filesystem Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**filesystem**\> | since C++17 | *std::path* class and supporting functions |

<p/>

## Standard Template Library (STL)

Standard Template Library (STL) is a sophisticated and powerful library of template classes and template functions that implement many common data structures and algorithms, and forms part of the C++ Standard Library. Refer to [STL FAQ: A Few Questions and Answers](http://cs.stmarys.ca/~porter/csc/ref/stl/faq.html), [C++ Standard Template Library (STL) Reference Material](http://cs.stmarys.ca/~porter/csc/ref/stl/index.html) and [Standard Template Library on Wikipedia](https://en.wikipedia.org/wiki/Standard_Template_Library).

The STL components are divided into six broad categories on the basis of functionality: **Containers**, **Iterators**, **Algorithms**, **Function Objects**, **Utilities**, and **Allocators**:

**Headers that provide access to STL containers and container adaptors**

![C++_STL_Header_01](/assets/C++_STL_Header_01.png)

* **vector**: Provides *linear, contiguous storage*, with fast inserts at the *back end only*. This class is often referred to as a **better array** that we should all now use in place of arrays. Like a great deal of free advice, this too should be followed with caution.
* **deque**: Provides *linear, non-contiguous storage*, with fast inserts at *both ends*.
* **list**: Provides *linear, doubly-linked storage*, with fast inserts *anywhere*.

* **map**: Provides *a collection of 1-to-1 mappings*, i.e. a collection of *key/value pairs* (pair objects) in which the first element of such a pair is a key and the second element of the pair is the value corresponding to that key, and the pair objects are maintained in sorted key order. In a map the keys must be unique.
* **multimap**: Like a **map**, except that pairs with duplicate keys are permitted.
* **set**: Provides a set of items which must have keys (or themselves be keys, in the simplest cases), with fast associative lookup. In a set the item keys must be unique, but (somewhat counter intuitively for a set) the item keys are ordered.
* **multiset**: Like a **set**, except that items with duplicate keys are permitted.

* **stack**: Adapts the **deque** container to provide strict last-in, first-out (LIFO) behavior.
* **queue**: Adapts the **deque** container to provide strict first-in, first-out (FIFO) behavior.
* **priority_queue**: Adapts the **vector** container to maintain items in a sorted order.

**Header that provides access to STL iterator facilities**

![C++_STL_Header_02](/assets/C++_STL_Header_02.png)

**Headers that provide access to STL algorithms**

![C++_STL_Header_03](/assets/C++_STL_Header_03.png)

**Header that provides access to STL functors, binders, negators and function adaptors**

![C++_STL_Header_04](/assets/C++_STL_Header_04.png)

**Header that provides access to STL utilities**

![C++_STL_Header_05](/assets/C++_STL_Header_05.png)

**Header that provides access to STL memory facilities**

![C++_STL_Header_06](/assets/C++_STL_Header_06.png)

## Open Source C++ Libraries

Refer to [open source C++ libraries](http://en.cppreference.com/w/cpp/links/libs) for a list of open source C++ libraries.

### SGI Standard Template Library

The SGI Standard Template Library, or STL, is a C++ library of container classes, algorithms, and iterators; it provides many of the basic algorithms and data structures of computer science. The STL is a generic library, meaning that its components are heavily parameterized: almost every component in the STL is a template. You should make sure that you understand how templates work in C++ before you use the STL. Refer to [Standard Template Library Programmer's Guide](http://www.sgi.com/tech/stl/).

### STLport

[STLport](http://stlport.sourceforge.net/) is a multiplatform C++ Standard Library implementation. It is a free, open-source product, featuring the following:

* Standard (ISO/IEC 14882) compliance;
* Advanced techniques and optimizations for maximum efficiency;
* Exception safety and thread safety;
* Important extensions: hash tables, singly-linked list, rope;
* Power debug mode: run time check of the correctness of iterators and containers usage.

# C++ Code Conventions

## MISRA C++

In the beginning **C** was considered unsuitable for safety critical and safety related systems, however, it was so used ...

In 1998, as a response to this situation, MISRA (Motor Industry Software Reliability Association) produced **MISRA C**, a set of guidelines to aid the development of safety related systems in **C** in the automotive world. Since then, MISRA C has been adopted by the wider embedded systems community and has become the dominant, international coding guidelines for the use of **C** in critical systems. The MISRA C guidelines are widely accepted as fulfilling the requirements for a language subset as required by both the 1994 MISRA *Development guidelines for vehicle based software* and IEC 61508.

Things move on, and now **C++** is in the position once held by **C**; many people believe that it should not be used for critical systems, but its use within the field is growing and that growth is without a common set of guidelines.

MISRA has recently completed work on the production of a set of guidelines for the use of C++ in critical systems, the output of which will be a set of guidelines similar to those that were produced for **C**.

Refer to [MISRA publications](https://www.misra.org.uk/Publications/tabid/57/Default.aspx) for more information.

### MISRA C++:2008

The document, known as **MISRA C++** *Guidelines for the use of the C++ language in critical systems*, was published and officially launched on 5 June 2008. Also refer to [C++ Programming Style Conventions Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_style.html).

## GNU Coding Standards

The GNU Coding Standards were written by Richard Stallman and other GNU Project volunteers. Their purpose is to make the GNU system clean, consistent, and easy to install. This document can also be read as a guide to writing portable, robust and reliable programs. It focuses on programs written in C, but many of the rules and principles are useful even if you write in another programming language. The rules often state reasons for writing in a certain way. Refer to [GNU Coding Standards](http://www.gnu.org/prep/standards/).

## Google C++ Style Guide

C++ is one of the main development languages used by many of Google's open-source projects. As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.

The goal of [this guide](https://google.github.io/styleguide/cppguide.html) is to manage this complexity by describing in detail the dos and don'ts of writing C++ code. These rules exist to keep the code base manageable while still allowing coders to use C++ language features productively.

*Style*, also known as readability, is what we call the conventions that govern our C++ code. The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.

Most open-source projects developed by Google conform to the requirements in [this guide](https://google.github.io/styleguide/cppguide.html).

# C++ Compilers

Refer to [C++ compiler support](http://en.cppreference.com/w/cpp/compiler_support) for compiler support for new C++ features.

## GCC (GNU Compiler Collection)

The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Ada, and Go, as well as libraries for these languages (libstdc++,...). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user's freedom.

Refer to [GCC official site](https://gcc.gnu.org/) and [GCC online documentation](https://gcc.gnu.org/onlinedocs/).

## Clang

The goal of the Clang project is to create a new C based language front-end: C, C++, Objective C/C++, OpenCL C and others for the LLVM compiler.

Refer to [Clang official site](http://clang.llvm.org/) and [Clang Compiler User’s Manual](http://clang.llvm.org/docs/UsersManual.html).

## Microsoft Visual C++

Refer to [Microsoft Development Tools and Languages](https://msdn.microsoft.com/en-us/library/aa187916.aspx) and [Visual Studio](https://docs.microsoft.com/en-us/visualstudio/welcome-to-visual-studio). Also refer to [Visual C++ Quick References](http://cs.stmarys.ca/~porter/csc/ref/index_visualcpp.html).

## EDG eccp

The C++ front end supports the ISO/IEC 14882 standard. The C++14, C++11, and C++98/03 versions of the language are fully supported. (see our description of language features).

Under control of command-line options, the front end also supports ANSI/ISO C (both C89 and C99, and the Embedded C TR), the Microsoft dialects of C and C++ (including C++/CLI), GNU C and C++, Clang C and C++, Sun C++, the cfront 2.1 and 3.0.n dialects of C++, and K&R/pcc C.

Refer to [EDG (Edison Design Group) eccp](https://www.edg.com/c).

## Intel C++ Compiler

If you are here, you are looking for ways to make your application run faster. Boost performance by augmenting your development process with the Intel C++ Compiler. The Intel C++ Compiler plugs right into popular development environments like Visual Studio, Eclipse, XCode, and Android Studio; The Intel C++ Compiler is compatible with popular compilers including Visual C++ (Windows) and GCC (Linux, OS X and Android).

Refer to [Intel C++ Compiler official site](https://software.intel.com/en-us/intel-compilers/).

## IBM XL C++

IBM XL C and C++ compilers offer advanced compiler and optimization technologies and are built on a common code base for easier porting of your applications between platforms. They comply with the latest C/C++ international standards and industry specifications and support a large array of common language features.

Refer to [IBM XLC++ official site](http://www-03.ibm.com/software/products/en/ccompfami).

## Sun/Oracle C++

The C++ compiler (CC) supports the ISO International Standard for C++, **ISO IS 14882:1998, Programming Language--C++**. The README file that accompanies the current release describes any departures from requirements in the standard. Refer to [Sun/Oracle C++ User Guide](http://docs.oracle.com/cd/E19957-01/806-3572/C++UserGuideTOC.html).

## Embarcadero C++ Builder

Develop for many platforms in fast, modern C++ with an enhanced Clang compiler. Seamlessly compile and deploy across platforms and devices. Design a UI once, then quickly specialize for each platform or device - much like subclassing code. Use robust and powerful frameworks for enterprise-strength databases, REST, cloud, IoT and more - whether you’re a team of a hundreds or a micro-startup. Accelerate your development: spend more time coding, less time on UI design, no time on platform-specific porting.

C++Builder gives you fast, powerful, modern C++; one compiler, one debugger, one IDE, four platforms; amazing frameworks; and lets you speed up your development, focus on your code and bring your app to market faster than any other C++ toolchain.

Refer to [Embarcadero C++ Builder official site](https://www.embarcadero.com/products/cbuilder).

## Cray C++ Compiler

The Cray Compiling Environment (CCE) contains both the Cray C and C++ compilers. The Cray C compiler conforms to the International Organization of Standards (ISO) standard ISO/IEC 9899:1999 (C99). The Cray C++ compiler conforms to the ISO/IEC 14882:2003 standard, with some exceptions.

Refer to [Cray C and C++ Reference Manual](http://docs.cray.com/books/S-2179-81/S-2179-81.pdf).

## Digital Mars C++

Digital Mars D compilers for Win32, Linux and OS X. C and C++ Compilers for Win32, Win16, DOS32 and DOS. Fastest compile/link times, powerful optimization technology, Design by Contract, complete library source, HTML browsable documentation, disassembler, librarian, resource compiler, make, etc., command line and GUI versions, tutorials, sample code, online updates, Standard Template Library, and much more.

Refer to [Digital Mars C++](http://digitalmars.com/).

## Coliru Online Compiler

[Coliru Online Compiler](http://coliru.stacked-crooked.com/)

# C++ FAQ

Refer to [Bjarne Stroustrup's C++ Style and Technique FAQ](http://www.stroustrup.com/bs_faq2.html).

## 字节序(Endianness)

[Endian的由来](http://www.eygle.com/digest/2007/01/whats_mean_endian.html)

对于单一的字节(a byte)，大部分处理器以相同的顺序处理比特位(bit)，因此单字节的存放方法和传输方式一般是相同的。

字节序是指存放多字节数据的字节(byte)的顺序，典型的情况是整数在内存中的存放方式和网络传输的传输顺序。Endianness有时候也可以用指位序(bit)。

一般而言，字节序指示了一个UCS-2字符的哪个字节存储在低地址。如果LSByte在MSByte的前面，即LSB为低地址，则该字节序是**小端序**；反之则是**大端序**。在网络编程中，字节序是一个必须被考虑的因素，因为不同的处理器体系可能采用不同的字节序。在多平台的代码编程中，字节序可能会导致难以察觉的bug。

* Big-endian

![Big-endian](/assets/big-endian.png)

* Little-endian

![Little-endian](/assets/little-endian.png)

## ++/--操作符

编程时应该尽可能使用递增操作符(++)和递减操作符(--)的前缀形式，因为它少创建两个临时对象，效率比较高。从代码来分析：

递增操作符(++)和递减操作符(--)的前缀形式：

```
T& T::operator++(){
    ++*this;
    return *this;
}

T& T::operator--(){
    --*this;
    return *this;
}
```

递增操作符(++)和递减操作符(--)的后缀形式：

```
T T::operator++(int){
    T old(*this);
    ++*this;
    return old;
}

T T::operator--(int){
    T old(*this);
    --*this;
    return old;
}
```

递增操作符(++)和递减操作符(--)的后缀形式所多花费的开销:

```
T old(*this);
```

这一句产生一个类型为T的临时对象old，并用原值*this进行初始化。当函数return时，又再次创建一个临时对象，并用old的值进行初始化，之后，局部变量old被销毁。并用临时创建的变量对赋值符左边的变量进行赋值(如果有的话)，赋值后，临时变量再次被销毁。

而对于递增操作符(++)和递减操作符(--)的后缀形式，首先函数内没有创建临时变量，故这方面的开销就节省了。其次，返回的是一个引用，故也节省了这时候创建销毁临时对象的开销。

因此后缀式的自增自减，所多花费的开销是两次临时变量的创建，以及两次临时变量的销毁。如果自增自减的对象不是内建的数据类型，而一个类类型（当然，你首先得重载自增自减操作符），那么这个开销可能会比较大。因为变成了两次构造函数以及两次析构函数的调用。

所以在调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回原值。

### 处理器体系

* x86, MOS Technology 6502, Z80, VAX, PDP-11等处理器为Little endian。
* Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC (除V9外)等处理器为Big endian。
* ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。

### 网络序

网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。

伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl(), htons()用于本机序转换到网络序；ntohl(), ntohs()用于网络序转换到本机序。

### Big Endian to Little Endian Data Conversion Using 3.3V Bus Switches

![Big_Endian_to_Little_Endian_Data_Conversion](/docs/Big_Endian_to_Little_Endian_Data_Conversion.pdf)

## VC字节对齐规则

关键字：

```
#pragma pack(n)
#pragma pack()
```

* 结构体中变量的偏移

    * 默认情况下，VC规定，结构体各成员变量存放的起始地址相对于结构体的起始地址的偏移量，必须为该变量的类型所占用的字节数的整数倍。
    * 若n大于等于该变量的类型所占用的字节数，则偏移量必须满足默认的字节对齐方式。
    * 若n小于该变量的类型所占用的字节数，则偏移量为n的整数倍，不用满足默认的对齐方式。

* 结构体总大小的约束

    * 若n大于所有成员变量的类型所占用的字节数，则结构体总大小必须为占用空间最大的成员变量所占用空间的整数倍；否则，必须为n的整数倍。
    * 所有因为偏移而引起的字节空缺，将由VC自动填补，没有放置任何有意义的东西。

# C++ Notes

**继承和组合的关系**

* 继承是 is-a 的关系
* 组合是 has-a 的关系

**C++三要素**

* 封装 -- 数据抽象
* 继承 -- 代码重用
* 多态 -- 虚函数

**指针和引用**

* 在使用指针前必须判断指针的合法性。
* 而对于引用参数来说，函数不必做类似的检查，因为引用机制本身保证了它一定会指向一个有效的对象。引用必须被初始化为指向一个对象，而且初始化后就不能再指向其他对象了，而指针可以指向一个对象或者没有指向任何对象。
* 如果需要改变的是指针本身的内容（而不是指针所指向的内容），则需要使用指针的引用来做为函数的参数。

```
void AllocMem(int *&p)
{
	p = new int;
}

int main()
{
	int *pTmp = 0;
	AllocMem(pTmp);
	*pTmp = 3;

	return 0;
}
```

**函数重载**

* const用在传值参数上，不能做为重载的依据

```
void fun(int);              ×
void fun(const int);        ×
```

* const用在指针上，可以做为重载的依据

```
void f(int *);              √
void f(const int *);        √
```

* const用在引用上，可以做为重载的依据

```
void f(int &);              √
void f(const int &);        √
```

* const用在函数本身，可以做为重载的依据

```
void f(int);                √
void f(int) const;          √
```

**什么时候需要定义复制构造函数和赋值操作符**

* 类对象初始化时需要动态配置内存

**在字节对齐方式下，CPU的运行效率明显快多了，这就是要对齐的原因**

* VC在缺省情况下，是8字节对齐
* #pragma

```
#pragma pack(push)
#pragma pack(...)
...
#pragma pack(pop)
```

**判断两个浮点完全相等**

```
if (!(a > b || a < b))
```

**子类的继承**

* 在子类的空间里，继承了父类的私有变量，但是子类不能直接访问这些继承来的私有变量。

**if语句的写法**

* ```if (n == 10)```    // 第一种判断方式
* ```if (10 == n)```    // 第二种判断方式。这种方式更好，因为这样如果少了个=号，编译时就会报错，减少了出错的可能性

**判断一个操作系统位数**

* 用C++写个程序，如何判断一个操作系统是16位还是32位的？不能用sizeof()函数

```
/* Answer #1 */
// 16位的系统下，
int i = 65536;
cout << i<<endl; // 输出0；
int i = 65535;
cout << i<<endl; // 输出-1；

// 32位的系统下，
int i = 65536;
cout << i<<endl; // 输出65536；
int i = 65535;
cout << i<<endl; // 输出65535；

/* Answer #2 */
int a = 65537;
if (a & 0xFFFF)
{
    cout<<"32 bit"<<endl;
}
else
{
    cout<<"16 bit"<<endl;
}
```

**交换两个参数的值**

* 在不用第三方参数的情况下，交换两个参数的值

```
#include <stdio.h>

/* Method #1 */
void main()
{
    int i=60, j=50;
    i = i + j;
    j = i - j;
    i = i - j;
    printf("i=%d\n",i);
    printf("j=%d\n",j);
}

/* Method #2 */
i ^= j;
j ^= i;
i ^= j;

/* Method #3: 用加减实现，而且不会溢出 */
a = a + b - (b = a)；
```

# Books

* **C++ Primer, 3rd Edition**

# References

* [Bjarne Stroustrup's homepage](http://www.stroustrup.com/)
* [News, Status & Discussion about Standard C++](https://isocpp.org/)
* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html">Linux: C/C++ Libraries</a>
* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)
* [JTC1/SC22/WG21 - Papers 2011](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/)
* [C++0x FAQ](http://www2.research.att.com/~bs/C++0xFAQ.html)
* [C++ programming language on Wikipedia](https://en.wikipedia.org/wiki/C%2B%2B)
* [C/C++ Reference](http://en.cppreference.com/w/)
* [cplusplus.com](http://www.cplusplus.com/)
* [C++ Reference Material from Saint Mary's University](http://cs.stmarys.ca/~porter/csc/ref/index_cpp.html)
* [C++ Reference Material: Strings in C and C++](http://cs.stmarys.ca/~porter/csc/ref/c_cpp_strings.html)
* [C++ Reference Material: Input and Output](http://cs.stmarys.ca/~porter/csc/ref/cpp_io.html)
* [MISRA C++](https://www.misra-c.com/MISRAChome/tabid/181/Default.aspx)
* [GCC](https://gcc.gnu.org/)
