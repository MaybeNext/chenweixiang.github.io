---
layout: post
title: "C++"
tag: Programming Languages
toc: true
---

This article introduces the **C++** programming language.

<!--more-->

# Overview

**C++**, high-level computer programming language. Developed by *Bjarne Stroustrup* of Bell Laboratories in the early 1980s, it is based on the traditional **C** language but with added object-oriented programming and other capabilities. C++, along with Java, has become popular for developing commercial software packages that incorporate multiple interrelated applications. C++ is considered one of the fastest languages and is very close to low-level languages, thus allowing complete control over memory allocation and management. This very feature and its many other capabilities also make it one of the most difficult languages to learn and handle on a large scale.

# C++ Standards

![C++ Language Evolution](/assets/CPP_Language_Evolution.png)

C++ is standardized by the International Organization for Standardization (ISO) [C++ Standards Committee (JTC1/SC22/WG21 - C++)](http://www.open-std.org/jtc1/sc22/wg21/). So far, it has seen following versions of C++ released. Besides, the C++ standards committee publishes [experimental C++ language and library extensions](http://en.cppreference.com/w/cpp/experimental) for future standardization.

* **ISO/IEC 14882:1998 (C++98)**

    In 1998, the ISO working group standardized C++ for the first time as **ISO/IEC 14882:1998**, which is informally known as **C++98**.

* **ISO/IEC 14882:2003 (C++03)**

    In 2003, ISO working group published a new version of the C++ standard called **ISO/IEC 14882:2003**, which is informally known as **C++03**. This version of the C++ standard fixed problems identified in **C++98**.

* **ISO/IEC TR 18015:2006** - Technical Report on C++ Performance

    The aim of ISO/IEC TR 18015 is to:

    * give the reader a model of time and space overheads implied by use of various C++ language and library features;
    * debunk widespread myths about performance problems in C++;
    * present techniques for use of C++ in applications where performance matters; and
    * present techniques for implementing C++ standard language and library facilities to yield efficient code.
    <p/>
    The special needs of embedded systems programming are presented, including ROMability and predictability. A separate chapter presents general C and C++ interfaces to the basic hardware facilities of embedded systems.

* **ISO/IEC TR 19768:2007 (C++TR1)** - Technical Report on C++ Library Extensions

    In 2007, a technical report **ISO/IEC TR 19768:2007 - C++ Library Extensions** was released, which is informally known as **C++07/TR1**. While not an official part of the standard, it proposed a number of extensions to the standard library.

* **ISO/IEC TR 29124:2010** - Extensions to the C++ Library to support mathematical special functions

    In 2010, a technical report **ISO/IEC TR 29124:2010 - C++ Special Math Functions** is released. The draft can be found [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf).

* **ISO/IEC 14882:2011 (C++11)**

    In 2011, a major revision of the standard was informally referred to as ***C++0x***, but it was not released until 2011. The **ISO/IEC 14882:2011 (C++11)** included most of the library enhancements of **C++07/TR1**, as well as many additions to the core language.

* **ISO/IEC TR 24733:2011** - Extensions for the programming language C++ to support decimal floating-point arithmetic

    In 2011, a technical report **ISO/IEC TR 24733:2011 - C++ decimal floating point arithmetic extensions** is released. The draft can be found [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2849.pdf).

* **ISO/IEC 14882:2014 (C++14)**

    In 2014, **C++14** (also known as ***C++1y***) was released as a small extension to **C++11**, featuring mainly bug fixes and small improvements.

* **ISO/IEC TS 18822:2015** - File System Technical Specification

    ISO/IEC TS 18822:2015 specifies requirements for implementations of an interface that computer programs written in the C++ programming language may use to perform operations on file systems and their components, such as paths, regular files, and directories. This Technical Specification is applicable to information technology systems that can access hierarchical file systems, such as those with operating systems that conform to the POSIX (3) interface. This Technical Specification is applicable only to vendors who wish to provide the interface it describes.

* **ISO/IEC TS 19570:2015** - Technical Specification for C++ Extensions for Parallelism

Also refer to the following links:

* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)
* [News, Status & Discussion about Standard C++](https://isocpp.org/)
* [Current Status of C++ Standard](https://isocpp.org/std/status)

![C++ standard timeline](/assets/C++-wg21-timeline.png)

# C++ Language

## Keywords

This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading. Also refer to [C++ Keywords Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_keywords.html).

|     Keywords     |  Standard   |
| :--------------- | :---------: |
| alignas          | since C++11 |
| alignof          | since C++11 |
| and              |             |
| and_eq           |             |
| asm              |             |
| atomic_cancel    | TM TS       |
| atomic_commit    | TM TS       |
| atomic_noexcept  | TM TS       |
| auto             | (1)         |
| bitand           |             |
| bitor            |             |
| bool             |             |
| break            |             |
| case             |             |
| catch            |             |
| char             |             |
| char16_t         | since C++11 |
| char32_t         | since C++11 |
| class            | (1)         |
| compl            |             |
| concept          | concepts TS |
| const            |             |
| constexpr        | since C++11 |
| const_cast       |             |
| continue         |             |
| decltype         | since C++11 |
| default          | (1)         |
| delete           | (1)         |
| do               |             |
| double           |             |
| dynamic_cast     |             |
| else             |             |
| enum             |             |
| explicit         |             |
| export           | (1)         |
| extern           | (1)         |
| false            |             |
| float            |             |
| for              |             |
| friend           |             |
| goto             |             |
| if               |             |
| import           | modules TS  |
| inline           | (1)         |
| int              |             |
| long             |             |
| module           | modules TS  |
| mutable          | (1)         |
| namespace        |             |
| new              |             |
| noexcept         | since C++11 |
| not              |             |
| not_eq           |             |
| nullptr          | since C++11 |
| operator         |             |
| or               |             |
| or_eq            |             |
| private          |             |
| protected        |             |
| public           |             |
| register         | (2)         |
| reinterpret_cast |             |
| requires         | concepts TS |
| return           |             |
| short            |             |
| signed           |             |
| sizeof           | (1)         |
| static           |             |
| static_assert    | since C++11 |
| static_cast      |             |
| struct           | (1)         |
| switch           |             |
| synchronized     | TM TS       |
| template         |             |
| this             |             |
| thread_local     | since C++11 |
| throw            |             |
| true             |             |
| try              |             |
| typedef          |             |
| typeid           |             |
| typename         |             |
| union            |             |
| unsigned         |             |
| using            | (1)         |
| virtual          |             |
| void             |             |
| volatile         |             |
| wchar_t          |             |
| while            |             |
| xor              |             |
| xor_eq           |             |

<p/>

NOTE:

* (1) - meaning changed or new meaning added in **C++11**. Note: the keyword *export* is also used by Modules TS.
* (2) - meaning changed in **C++17**.

Note that ```and```, ```bitor```, ```or```, ```xor```, ```compl```, ```bitand```, ```and_eq```, ```or_eq```, ```xor_eq```, ```not```, and ```not_eq``` (along with the digraphs ```<%```, ```%>```, ```<:```, ```:>```, ```%:```, and ```%:%:```) provide an alternative way to represent standard tokens.

### Alternative Tokens

There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the stringification operator can make the spelling visible). The two-letter alternative tokens are sometimes called **digraphs**:

| Primary  | Alternative |
| :------: | :---------- |
| ```&&``` | and         |
| ```&=``` | and_eq      |
| ```&```  | bitand      |
| ```|```  | bitor       |
| ```~```  | compl       |
| ```!```  | not         |
| ```!=``` | not_eq      |
| ```||``` | or          |
| ```|=``` | or_eq       |
| ```^```  | xor         |
| ```^=``` | xor_eq      |
| ```{```  | ```<%```    |
| ```}```  | ```%>```    |
| ```[```  | ```<:```    |
| ```]```  | ```:>```    |
| ```#```  | ```%:```    |
| ```##``` | ```%:%:```  |

<p/>

## Operators

Refer to [C++ Operators Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_operators.html).

| Operators                                                                                           | Associativity     |
| :-------------------------------------------------------------------------------------------------- | :---------------: |
| ```()``` ```[]``` ```->``` ```.```                                                                  | left to right     |
| ```!``` ```~``` ```++``` ```--``` ```+``` ```-``` ```(type)``` ```*``` ```&``` ```sizeof```         | **right to left** |
| ```*``` ```/``` ```%```                                                                             | left to right     |
| ```+``` ```-```                                                                                     | left to right     |
| ```<<``` ```>>```                                                                                   | left to right     |
| ```<``` ```<=``` ```>``` ```>=```                                                                   | left to right     |
| ```==``` ```!=```                                                                                   | left to right     |
| ```&```                                                                                             | left to right     |
| ```^```                                                                                             | left to right     |
| ```|```                                                                                             | left to right     |
| ```&&```                                                                                            | left to right     |
| ```||```                                                                                            | left to right     |
| ```?:```                                                                                            | **right to left** |
| ```=``` ```+=``` ```-=``` ```*=``` ```/=``` ```%=``` ```<<=``` ```>>=``` ```&=``` ```^=``` ```|=``` | **right to left** |
| ```,```                                                                                             | left to right     |

<p/>

Run the following command to get the operator priority under Linux environment:

```
chenwx@chenwx ~ $ man operator

NAME
       operator - C operator precedence and order of evaluation

DESCRIPTION
       This manual page lists C operators and their precedence in evaluation.

       Operator                             Associativity
       () [] -> .                           left to right
       ! ~ ++ -- + - (type) * & sizeof      right to left
       * / %                                left to right
       + -                                  left to right
       << >>                                left to right
       < <= > >=                            left to right
       == !=                                left to right
       &                                    left to right
       ^                                    left to right
       |                                    left to right
       &&                                   left to right
       ||                                   left to right
       ?:                                   right to left
       = += -= *= /= %= <<= >>= &= ^= |=    right to left
       ,                                    left to right

COLOPHON
       This page is part of release 3.54 of the Linux man-pages project.  A description of the project, and information about reporting bugs, can befound at http://www.kernel.org/doc/man-pages/.
```

## Comments

## Data Types

## Classes

### class

#### 类的构造函数

* 构造函数与类同名，且无返回类型。
* C++语言对于一个类可以声明多少个构造函数没有限制，只要每个构造函数的参数表是惟一的即可。
* 缺省构造函数是指不需要用户指定实参就能够被调用的构造函数，这并不意味着它不能接受实参，只意味着构造函数的每个参数都有一个缺省值与之关联。
* 构造函数的可访问性由其声明所在的访问区来决定。若把构造函数放到非公有访问区内，从而会限制或显式禁止某些形式的对象创建动作。
* 用一个类对象初始化该类的另一个对象被称为缺省按成员初始化。在概念上，一个类对象向该类的另一个对象作拷贝是通过依次拷贝每个非静态数据成员来实现的。类的设计者也可以通过提供特殊的拷贝构造函数来改变缺省的行为。如果定义了拷贝构造函数，则在用一个类对象初始化该类另一个对象时它就会被调用。

构造函数的调用顺序总是如下:

1. **基类构造函数**。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
2. **成员类对象构造函数**。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
3. **派生类构造函数**。作为一般规则，派生类构造函数应该不能直接向一个基类数据成员赋值，给适当的基类构造函数。

#### 类的析构函数

* 析构函数是一个特殊的、由用户定义的成员函数，当该类的对象离开了它的域，或者delete表达式应用到一个该类的对象的指针上时，析构函数会自动被调用。
* 析构函数的名字是在类名前加上波浪线（~），它不返回任何值，也没有任何参数。因为它不能指定任何参数，因而它也不能被重载。
* 尽管我们可以为一个类定义多个构造函数，但是我们只能提供一个析构函数，它将被应用在类的所有对象上。

派生类的析构函数调用顺序与它的构造函数调用顺序相反，因而析构函数的调用顺序如下：

1. **派生类析构函数**
2. **成员类对象析构函数**
3. **基类析构函数**

#### 静态成员变量

静态成员变量被当作类的全局对象。对于非静态成员变量，每个类对象都有自己的拷贝，而静态成员变量对每个类类型只有一个拷贝。**静态成员变量只有一份，由该类类型的所有对象共享访问。**

同全局对象相比，使用静态成员变量有两个优势：
1. 静态成员变量没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性；
2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局对象不能。

在类体中的成员变量声明前面加上关键字static就使该成员变量成为静态的。static成员变量遵从public, private, protected访问规则。

静态成员变量在该类定义之外被初始化，如同一个成员函数被定义在类定义之外一样，在这种定义中的静态成员变量的名字必须被其类名限定修饰，例如：

```
#include "account.h"
double Account::_interestRate = 0.0589;
```

与全局对象一样，对于静态成员变量，在程序中也只能提供一个定义。这意味着，静态成员变量的初始化不应该被放在头文件中，而应该放在含有类的非inline函数定义的文件中。静态成员变量可以被声明为任意类型，它们可以是const对象、数组或类对象等。

#### 多态性

* 用virtual关键字声明的函数叫做虚函数，虚函数肯定是类的成员函数。
* 包含虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
* **多态性是一个接口多种实现**，是面向对象的核心。分为**类的多态性**和**函数的多态性**。
* **多态用虚函数来实现，结合动态绑定**。
* 虚函数只能借助于指针或者引用来达到多态的效果。
* 纯虚函数是虚函数再加上=0。
* 抽象类是指包括至少一个纯虚函数的类。

### struct

The class keys ```struct``` and ```class``` are indistinguishable in C++, except that the *default access mode* and *default inheritance mode* are **public** if class declaration uses the **struct** class-key and **private** if the class declaration uses the **class** class-key. Both class and struct can be used in a class definition.

位结构是一种特殊的结构，在需要按位访问一个字节或字的多个比特位时，位结构比按位运算符更加方便。位结构定义的一般形式为:

```
struct 位结构名
{
    数据类型 变量名: 整型常数;
    数据类型 变量名: 整型常数;
} 位结构变量;
```

其中: 数据类型必须是int (unsigned or signed)。整型常数必须是非负的整数，表示二进制位的个数，即表示有多少位。变量名是可选项，可以不命名, 这样规定是为了排列需要。

例如：

```
struct
{
    unsigned incon: 8;      /*incon占用低字节的0~7位，共8位*/
    unsigned txcolor: 4;	/*txcolor占用高字节的0~3位，共4位*/
    unsigned bgcolor: 3;	/*bgcolor占用高字节的4~6位，共3位*/
    unsigned blink: 1;  	/*blink占用高字节的第7位*/
} ch;
```

位结构成员的访问与结构成员的访问相同。例如: 访问上例位结构中的bgcolor成员可写成```ch.bgcolor```。注意:

1. 位结构中的成员可以定义为unsigned，也可定义为signed，但当成员长度为1时，会被认为是unsigned类型，因为单个位不可能具有符号。
2. 位结构中的成员不能使用数组和指针，但位结构变量可以是数组和指针，如果是指针，其成员访问方式同结构指针。
3. 位结构总长度(位数)，是各个位成员定义的位数之和，可以超过两个字节。
4. 位结构成员可以与其它结构成员一起使用。
5. 一个位域必须存储在同一个字节中，不能跨两个字节。若一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进制位。例如：

```
struct bs    
{    
    unsigned a:4
    unsigned :0 	/*空域*/
    unsigned b:4 	/*从下一单元开始存放*/
    unsigned c:4
}
```

For instance:

```
struct info
{
    char name[8];
    int age;
    struct addr address;
    float pay;
    unsigned state: 1;
    unsigned pay: 1;
} workers;
```

上例的结构定义了关于一个工人的信息。其中有两个位结构成员, 每个位结构成员只有一位, 因此只占一个字节但保存了两个信息, 该字节中第一位表示工人的状态, 第二位表示工资是否已发放。由此可见使用位结构可以节省存贮空间。

### union

The use of the class key ```union``` results in a union definition, which defines a class that holds only one of its data members at a time.

# Comparison of C and C++

# C++ Libraries

## C++ Standard Library

Refer to [C++ Standard Library Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_standlib.html), which is abbreviated to contain only the most frequently used items. The information included here is not meant to be complete or definitive in any way, but more of a quick reference or quick reminder of what something looks like if you need to look it up in a hurry, and you've left your handy hard-copy reference on the bus. Thus, infrequently used functions (or variations of functions) and other entities may not appear.

Also refer to [C++ Standard Library header files](http://en.cppreference.com/w/cpp/header).

**Utilities Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cstdlib**\> | | General purpose utilities: program control, dynamic memory allocation, random numbers, sort and search |
| \<**csignal**\> | | Functions and macro constants for signal management |
| \<**csetjmp**\> | | Macro (and function) that saves (and jumps) to an execution context |
| \<**cstdarg**\> | | Handling of variable length argument lists |
| \<**typeinfo**\> | | Runtime type information utilities |
| \<**typeindex**\> | since C++11 | *std::type_index* |
| \<**type_traits**\> | since C++11 | Compile-time type information |
| \<**bitset**\> | | *std::bitset* class template |
| \<**functional**\> | | Function objects, designed for use with the standard algorithms |
| \<**utility**\> | | Various utility components |
| \<**ctime**\> | | C-style time/date utilites |
| \<**chrono**\> | since C++11 | C++ time utilites |
| \<**cstddef**\> | | typedefs for types such as *size_t*, *NULL* and others |
| \<**initializer_list**\> | since C++11 | *std::initializer_list* class template |
| \<**tuple**\> | since C++11 | *std::tuple* class template |
| \<**any**\> | since C++17 | *std::any* class template |
| \<**optional**\> | since C++17 | *std::optional* class template |
| \<**variant**\> | since C++17 | *std::variant* class template |

<p/>

**Dynamic Memory Management**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**new**\> | | Low-level memory management utilities |
| \<**memory**\> | | Higher level memory management utilities |
| \<**scoped_allocator**\> | since C++11 | Nested allocator class |
| \<**memory_resource**\> | since C++17 | Polymorphic allocators and memory resources |

<p/>

**Numeric Limits**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**climits**\> | | limits of integral types |
| \<**cfloat**\> | | limits of float types |
| \<**cstdint**\> | since C++11 | fixed-size types and limits of other types |
| \<**cinttypes**\> | since C++11 | formatting macros, *intmax_t* and *uintmax_t* math and conversions |
| \<**limits**\> | | standardized way to query properties of arithmetic types |

<p/>

**Error Handling**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**exception**\> | | Exception handling utilities |
| \<**stdexcept**\> | | Standard exception objects |
| \<**cassert**\> | | Conditionally compiled macro that compares its argument to zero |
| \<**system_error**\> | since C++11 | defines *std::error_code*, a platform-dependent error code |
| \<**cerrno**\> | | Macro containing the last error number |

<p/>

**Strings Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cctype**\> | | functions to determine the type contained in character data |
| \<**cwctype**\> | | functions for determining the type of wide character data |
| \<**cstring**\> | | various narrow character string handling functions |
| \<**cwchar**\> | | various wide and multibyte string handling functions |
| \<**cuchar**\> | since C++11 | C-style Unicode character conversion functions |
| \<**string**\> | | *std::basic_string* class template |
| \<**string_view**\> | since C++17 | *std::basic_string_view* class template |

<p/>

**Containers Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**array**\> | since C++11 | *std::array* container |
| \<**vector**\> | | *std::vector* container |
| \<**deque**\> | | *std::deque* container |
| \<**list**\> | | *std::list* container |
| \<**forward_list**\> | since C++11 | *std::forward_list* container |
| \<**set**\> | | *std::set* and *std::multiset* associative containers |
| \<**map**\> | | *std::map* and *std::multimap* associative containers |
| \<**unordered_set**\> | since C++11 | *std::unordered_set* and *std::unordered_multiset* unordered associative containers |
| \<**unordered_map**\> | since C++11 | *std::unordered_map* and *std::unordered_multimap* unordered associative containers |
| \<**stack**\> | | *std::stack container* adaptor |
| \<**queue**\> | | *std::queue* and *std::priority_queue* container adaptors |

<p/>

**Algorithms Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**algorithm**\> | | Algorithms that operate on containers |
| \<**execution**\> | C++17 | Predefined execution policies for parallel versions of the algorithms |

<p/>

**Iterators Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**iterator**\> | | Container iterators |

<p/>

**Numerics Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**cmath**\> | | Common mathematics functions |
| \<**complex**\> | | Complex number type |
| \<**valarray**\> | | Class for representing and manipulating arrays of values |
| \<**random**\> | since C++11 | Random number generators and distributions |
| \<**numeric**\> | | Numeric operations on values in containers |
| \<**ratio**\> | since C++11 | Compile-time rational arithmetic |
| \<**cfenv**\> | since C++11 | Floating-point environment access functions |

<p/>

**Input/output Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**iosfwd**\> | | forward declarations of all classes in the input/output library |
| \<**ios**\> | | *std::ios_base* class, *std::basic_ios* class template and several typedefs |
| \<**istream**\> | | *std::basic_istream* class template and several typedefs |
| \<**ostream**\> | | *std::basic_ostream*, *std::basic_iostream* class templates and several typedefs |
| \<**iostream**\> | | several standard stream objects |
| \<**fstream**\> | | *std::basic_fstream*, *std::basic_ifstream*, *std::basic_ofstream* class templates and several typedefs |
| \<**sstream**\> | | *std::basic_stringstream*, *std::basic_istringstream*, *std::basic_ostringstream* class templates and several typedefs |
| \<**strstream**\> | | *std::strstream*, *std::istrstream*, *std::ostrstream* (deprecated) |
| \<**iomanip**\> | | Helper functions to control the format or input and output |
| \<**streambuf**\> | | *std::basic_streambuf* class template |
| \<**cstdio**\> | | C-style input-output functions |

<p/>

**Localization Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**locale**\> | | Localization utilities |
| \<**clocale**\> | | C localization utilities |
| \<**codecvt**\> | since C++11 | Unicode conversion facilities |

<p/>

**Regular Expressions Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**regex**\> | since C++11 | Classes, algorithms and iterators to support regular expression processing |

<p/>

**Atomic Operations Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**atomic**\> | since C++11 | Atomic operations library |

<p/>

**Thread support Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**thread**\> | since C++11 | *std::thread* class and supporting functions |
| \<**mutex**\> | since C++11 | mutual exclusion primitives |
| \<**shared_mutex**\> | since C++14 | shared mutual exclusion primitives |
| \<**future**\> | since C++11 | primitives for asynchronous computations |
| \<**condition_variable**\> | since C++11 | thread waiting conditions |

<p/>

**Filesystem Library**

| C++_Headers | Standard | Note |
| :---------- | :------- | :--- |
| \<**filesystem**\> | since C++17 | *std::path* class and supporting functions |

<p/>

## Standard Template Library (STL)

Standard Template Library (STL) is a sophisticated and powerful library of template classes and template functions that implement many common data structures and algorithms, and forms part of the C++ Standard Library. Refer to [STL FAQ: A Few Questions and Answers](http://cs.stmarys.ca/~porter/csc/ref/stl/faq.html) for more information.

* [C++ Standard Template Library (STL) Reference Material](http://cs.stmarys.ca/~porter/csc/ref/stl/index.html)
* [Standard Template Library Programmer's Guide](http://www.sgi.com/tech/stl/)
* [STLport](http://stlport.sourceforge.net/)

**Headers that provide access to STL containers and container adaptors**

![C++_STL_Header_01](/assets/C++_STL_Header_01.png)

**Header that provides access to STL iterator facilities**

![C++_STL_Header_02](/assets/C++_STL_Header_02.png)

**Headers that provide access to STL algorithms**

![C++_STL_Header_03](/assets/C++_STL_Header_03.png)

**Header that provides access to STL functors, binders, negators and function adaptors**

![C++_STL_Header_04](/assets/C++_STL_Header_04.png)

**Header that provides access to STL utilities**

![C++_STL_Header_05](/assets/C++_STL_Header_05.png)

**Header that provides access to STL memory facilities**

![C++_STL_Header_06](/assets/C++_STL_Header_06.png)

## Open Source C++ Libraries

# C++ Code Conventions

## MISRA C++

In the beginning **C** was considered unsuitable for safety critical and safety related systems, however, it was so used ...

In 1998, as a response to this situation, MISRA (Motor Industry Software Reliability Association) produced **MISRA C**, a set of guidelines to aid the development of safety related systems in **C** in the automotive world. Since then, MISRA C has been adopted by the wider embedded systems community and has become the dominant, international coding guidelines for the use of **C** in critical systems. The MISRA C guidelines are widely accepted as fulfilling the requirements for a language subset as required by both the 1994 MISRA *Development guidelines for vehicle based software* and IEC 61508.

Things move on, and now **C++** is in the position once held by **C**; many people believe that it should not be used for critical systems, but its use within the field is growing and that growth is without a common set of guidelines.

MISRA has recently completed work on the production of a set of guidelines for the use of C++ in critical systems, the output of which will be a set of guidelines similar to those that were produced for **C**.

Refer to [MISRA publications](https://www.misra.org.uk/Publications/tabid/57/Default.aspx) for more information.

### MISRA C++:2008

The document, known as **MISRA C++** *Guidelines for the use of the C++ language in critical systems*, was published and officially launched on 5 June 2008. Also refer to [C++ Programming Style Conventions Reference Material](http://cs.stmarys.ca/~porter/csc/ref/cpp_style.html).

## GNU Coding Standards

The GNU Coding Standards were written by Richard Stallman and other GNU Project volunteers. Their purpose is to make the GNU system clean, consistent, and easy to install. This document can also be read as a guide to writing portable, robust and reliable programs. It focuses on programs written in C, but many of the rules and principles are useful even if you write in another programming language. The rules often state reasons for writing in a certain way. Refer to [GNU Coding Standards](http://www.gnu.org/prep/standards/).

## Google C++ Style Guide

C++ is one of the main development languages used by many of Google's open-source projects. As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.

The goal of [this guide](https://google.github.io/styleguide/cppguide.html) is to manage this complexity by describing in detail the dos and don'ts of writing C++ code. These rules exist to keep the code base manageable while still allowing coders to use C++ language features productively.

*Style*, also known as readability, is what we call the conventions that govern our C++ code. The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.

Most open-source projects developed by Google conform to the requirements in [this guide](https://google.github.io/styleguide/cppguide.html).

# C++ Compilers

Refer to [C++ compiler support](http://en.cppreference.com/w/cpp/compiler_support) for compiler support for new C++ features.

## GCC (GNU Compiler Collection)

Refer to [GCC official site](https://gcc.gnu.org/) and [GCC online documentation](https://gcc.gnu.org/onlinedocs/).

## Clang

Refer to [Clang official site](http://clang.llvm.org/) and [Clang Compiler User’s Manual](http://clang.llvm.org/docs/UsersManual.html).

## Microsoft Visual C++

Refer to [Microsoft Development Tools and Languages](https://msdn.microsoft.com/en-us/library/aa187916.aspx) and [Visual Studio](https://docs.microsoft.com/en-us/visualstudio/welcome-to-visual-studio). Also refer to [Visual C++ Quick References](http://cs.stmarys.ca/~porter/csc/ref/index_visualcpp.html).

* Visual Studio 2017
* Visual Studio 2015
* Visual Studio 2013
* Visual Studio 2012
* Visual Studio 2005

## EDG eccp

Refer to [EDG (Edison Design Group) eccp](https://www.edg.com/c).

## Intel C++ Compiler

Refer to [Intel C++ Compiler official site](https://software.intel.com/en-us/intel-compilers/).

## IBM XLC++

Refer to [IBM XLC++ official site](http://www-03.ibm.com/software/products/en/ccompfami).

## Sun/Oracle C++

Refer to [Sun/Oracle C++ User Guide](http://docs.oracle.com/cd/E19957-01/806-3572/C++UserGuideTOC.html).

## Embarcadero C++ Builder

Refer to [Embarcadero C++ Builder official site](https://www.embarcadero.com/products/cbuilder).

## Cray C++ Compiler

Refer to [Cray C and C++ Reference Manual](http://docs.cray.com/books/S-2179-81/S-2179-81.pdf).

## Digital Mars C++

Refer to [Digital Mars C++](http://digitalmars.com/).

## Coliru Online Compiler

[Coliru Online Compiler](http://coliru.stacked-crooked.com/)

# C++ FAQ

Refer to [Bjarne Stroustrup's C++ Style and Technique FAQ](http://www.stroustrup.com/bs_faq2.html).

## 字节序(Endianness)

[Endian的由来](http://www.eygle.com/digest/2007/01/whats_mean_endian.html)

对于单一的字节(a byte)，大部分处理器以相同的顺序处理比特位(bit)，因此单字节的存放方法和传输方式一般是相同的。

字节序是指存放多字节数据的字节(byte)的顺序，典型的情况是整数在内存中的存放方式和网络传输的传输顺序。Endianness有时候也可以用指位序(bit)。

一般而言，字节序指示了一个UCS-2字符的哪个字节存储在低地址。如果LSByte在MSByte的前面，即LSB为低地址，则该字节序是**小端序**；反之则是**大端序**。在网络编程中，字节序是一个必须被考虑的因素，因为不同的处理器体系可能采用不同的字节序。在多平台的代码编程中，字节序可能会导致难以察觉的bug。

* Big-endian

![Big-endian](/assets/big-endian.png)

* Little-endian

![Little-endian](/assets/little-endian.png)

## ++/--操作符

编程时应该尽可能使用递增操作符(++)和递减操作符(--)的前缀形式，因为它少创建两个临时对象，效率比较高。从代码来分析：

递增操作符(++)和递减操作符(--)的前缀形式：

```
T& T::operator++(){
    ++*this;
    return *this;
}

T& T::operator--(){
    --*this;
    return *this;
}
```

递增操作符(++)和递减操作符(--)的后缀形式：

```
T T::operator++(int){
    T old(*this);
    ++*this;
    return old;
}

T T::operator--(int){
    T old(*this);
    --*this;
    return old;
}
```

递增操作符(++)和递减操作符(--)的后缀形式所多花费的开销:

```
T old(*this);
```

这一句产生一个类型为T的临时对象old，并用原值*this进行初始化。当函数return时，又再次创建一个临时对象，并用old的值进行初始化，之后，局部变量old被销毁。并用临时创建的变量对赋值符左边的变量进行赋值(如果有的话)，赋值后，临时变量再次被销毁。

而对于递增操作符(++)和递减操作符(--)的后缀形式，首先函数内没有创建临时变量，故这方面的开销就节省了。其次，返回的是一个引用，故也节省了这时候创建销毁临时对象的开销。

因此后缀式的自增自减，所多花费的开销是两次临时变量的创建，以及两次临时变量的销毁。如果自增自减的对象不是内建的数据类型，而一个类类型（当然，你首先得重载自增自减操作符），那么这个开销可能会比较大。因为变成了两次构造函数以及两次析构函数的调用。

所以在调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回原值。

### 处理器体系

* x86, MOS Technology 6502, Z80, VAX, PDP-11等处理器为Little endian。
* Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC (除V9外)等处理器为Big endian。
* ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。

### 网络序

网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。

伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl(), htons()用于本机序转换到网络序；ntohl(), ntohs()用于网络序转换到本机序。

### Big Endian to Little Endian Data Conversion Using 3.3V Bus Switches

![Big_Endian_to_Little_Endian_Data_Conversion](/docs/Big_Endian_to_Little_Endian_Data_Conversion.pdf)

## VC字节对齐规则

关键字：

```
#pragma pack(n)
#pragma pack()
```

* 结构体中变量的偏移

    * 默认情况下，VC规定，结构体各成员变量存放的起始地址相对于结构体的起始地址的偏移量，必须为该变量的类型所占用的字节数的整数倍。
    * 若n大于等于该变量的类型所占用的字节数，则偏移量必须满足默认的字节对齐方式。
    * 若n小于该变量的类型所占用的字节数，则偏移量为n的整数倍，不用满足默认的对齐方式。

* 结构体总大小的约束

    * 若n大于所有成员变量的类型所占用的字节数，则结构体总大小必须为占用空间最大的成员变量所占用空间的整数倍；否则，必须为n的整数倍。
    * 所有因为偏移而引起的字节空缺，将由VC自动填补，没有放置任何有意义的东西。

# C++ Notes

**继承和组合的关系**

* 继承是 is-a 的关系
* 组合是 has-a 的关系

**C++三要素**

* 封装 -- 数据抽象
* 继承 -- 代码重用
* 多态 -- 虚函数

**指针和引用**

* 在使用指针前必须判断指针的合法性。
* 而对于引用参数来说，函数不必做类似的检查，因为引用机制本身保证了它一定会指向一个有效的对象。引用必须被初始化为指向一个对象，而且初始化后就不能再指向其他对象了，而指针可以指向一个对象或者没有指向任何对象。
* 如果需要改变的是指针本身的内容（而不是指针所指向的内容），则需要使用指针的引用来做为函数的参数。

```
void AllocMem(int *&p)
{
	p = new int;
}

int main()
{
	int *pTmp = 0;
	AllocMem(pTmp);
	*pTmp = 3;

	return 0;
}
```

**函数重载**

* const用在传值参数上，不能做为重载的依据

```
void fun(int);              ×
void fun(const int);        ×
```

* const用在指针上，可以做为重载的依据

```
void f(int *);              √
void f(const int *);        √
```

* const用在引用上，可以做为重载的依据

```
void f(int &);              √
void f(const int &);        √
```

* const用在函数本身，可以做为重载的依据

```
void f(int);                √
void f(int) const;          √
```

**什么时候需要定义复制构造函数和赋值操作符**

* 类对象初始化时需要动态配置内存

**在字节对齐方式下，CPU的运行效率明显快多了，这就是要对齐的原因**

* VC在缺省情况下，是8字节对齐
* #pragma

```
#pragma pack(push)
#pragma pack(...)
...
#pragma pack(pop)
```

**判断两个浮点完全相等**

```
if (!(a > b || a < b))
```

**子类的继承**

* 在子类的空间里，继承了父类的私有变量，但是子类不能直接访问这些继承来的私有变量。

**if语句的写法**

* ```if (n == 10)```    // 第一种判断方式
* ```if (10 == n)```    // 第二种判断方式。这种方式更好，因为这样如果少了个=号，编译时就会报错，减少了出错的可能性

**判断一个操作系统位数**

* 用C++写个程序，如何判断一个操作系统是16位还是32位的？不能用sizeof()函数

```
/* Answer #1 */
// 16位的系统下，
int i = 65536;
cout << i<<endl; // 输出0；
int i = 65535;
cout << i<<endl; // 输出-1；

// 32位的系统下，
int i = 65536;
cout << i<<endl; // 输出65536；
int i = 65535;
cout << i<<endl; // 输出65535；

/* Answer #2 */
int a = 65537;
if (a & 0xFFFF)
{
    cout<<"32 bit"<<endl;
}
else
{
    cout<<"16 bit"<<endl;
}
```

**交换两个参数的值**

* 在不用第三方参数的情况下，交换两个参数的值

```
#include <stdio.h>

/* Method #1 */
void main()
{
    int i=60, j=50;
    i = i + j;
    j = i - j;
    i = i - j;
    printf("i=%d\n",i);
    printf("j=%d\n",j);
}

/* Method #2 */
i ^= j;
j ^= i;
i ^= j;

/* Method #3: 用加减实现，而且不会溢出 */
a = a + b - (b = a)；
```

# Books

* **C++ Primer, 3rd Edition**

# References

* [Bjarne Stroustrup's homepage](http://www.stroustrup.com/)
* [News, Status & Discussion about Standard C++](https://isocpp.org/)
* <a href="{{ site.base-url }}/2015/12/18/linux-series-05-libraries.html">Linux: C/C++ Libraries</a>
* [JTC1/SC22/WG21 - The C++ Standards Committee](http://www.open-std.org/jtc1/sc22/wg21/)
* [JTC1/SC22/WG21 - Papers 2011](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/)
* [C++0x FAQ](http://www2.research.att.com/~bs/C++0xFAQ.html)
* [C++ programming language on Wikipedia](https://en.wikipedia.org/wiki/C%2B%2B)
* [C/C++ Reference](http://en.cppreference.com/w/)
* [C++ Reference Material from Saint Mary's University](http://cs.stmarys.ca/~porter/csc/ref/index_cpp.html)
* [C++ Reference Material: Strings in C and C++](http://cs.stmarys.ca/~porter/csc/ref/c_cpp_strings.html)
* [C++ Reference Material: Input and Output](http://cs.stmarys.ca/~porter/csc/ref/cpp_io.html)
* [MISRA C++](https://www.misra-c.com/MISRAChome/tabid/181/Default.aspx)
* [GCC](https://gcc.gnu.org/)
